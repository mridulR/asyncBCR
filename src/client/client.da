#!/usr/bin/python3
# -*- coding: utf-8 -*-
import sys
import os
import logging
import time
from src.utils import Logger
from src.utils import config_parser
from random import randint
import re
import random

# Configuration keys for client

NUM_OF_CLIENTS = 'num_client'
CLIENT_TIMEOUT = 'client_timeout'
CLIENT_HOSTS = 'client_hosts'
WORK_LOAD = 'workload'


class client(process):

    def setup(config_file, client_no, olympus, olympus_name,
              name, nodeId,):

        config = config_parser.get_config(config_file)
        self.time_out = config[CLIENT_TIMEOUT]

        self.current_replicas = []
        # Setting the logging format for the CONFIG_NODE
        # Default logging is INFO for CONFIG_NODE.
        # Other applicable values - logging.WARN, logging.CRITICAL,
        # logging.ERROR, logging.DEBUG
        # Use respective logging.warn, logging.critical, logging.error,
        # logging.debug

        Logger.setLogFormatting(self.name + '.log', Logger.getLogDir(),
                                logging.INFO)
        Logger.setLogNodeInfo(self.nodeId, self.name)

        # Log the received values

        logging.info("Client {clientId: %s, clientName: %s} received setup - "  +
                     "config_file: %s client_no: %s olympus - {olympusId: %s, " +
                     "olympusName: %s}", self.nodeId,
                     self.name, self.config_file, str(self.client_no),
                     self.olympus, self.olympus_name,
                     extra=Logger.NODE_INFO)
        return
        
    def receive(msg=('rcv_curr_config', replicas), from_=self.olympus):
        if int(len(replicas)) > 0:
            print("Setting current replicas set message to head : ")
            self.current_replicas = replicas
        else:
            print("No replica to send order request to !!!")

        return


    def receive(msg=('result_proof', result_proof, replica_no)):
        output("Received result_proof from replica ReplicaNode", str(replica_no))
        output(result_proof)

        logging.info("client { clientId: %s, clientName: %s} received " +
                     "result_proof from replica {replicaId: %s, replicaName:" +
                     "%s}", self.nodeId, self.name, str(replica_no),
                     str(replica_no), extra=Logger.NODE_INFO)
        return

    def receive(msg=('retransmission_result', result_proof, replica_no)):
        print ("Received Retransmission result")

    def generate_psedorandom(seed, num):
        orders = []
        supported_operations = ['put', 'get', 'append', 'slice']
        for ind in range(0, num):
            rand_num = random.randint(seed, seed + num)
            rand_index = rand_num % 4
            rand_oper = supported_operations[rand_index]
            rand_key = 'randKey' + str(rand_num)
            rand_value = 'randValue' + str(rand_num)
            if rand_index == 0:
                orders.append(rand_oper + '(' + rand_key + ',' + rand_value + ')')
            elif rand_index == 1:
                orders.append(rand_oper + '(' + rand_key + ')')
            elif rand_index == 2:
                append_value = 'append_rand' + str(random.randint(seed, seed + num))
                orders.append(rand_oper + '(' + rand_key + ',' + append_value + ')')
            elif rand_index == 3:
                expected_len = len(rand_value)
                slice_start = 1
                slice_end = expected_len - 2
                orders.append(rand_oper + '(' + rand_key + ',' \
                    + str(slice_start) + ':' + str(slice_end) + ')')
        return orders

    def execute_order(order):
        send(('req_curr_config', self), to=olympus)
        await(some(received(('rcv_curr_config', _))))
        request_id = randint(1, 9000)
        if len(current_replicas) > 0:
            send(('request_order', self, request_id, order), \
                to=current_replicas[0])
            if await(len(setof(a, received(('result_proof', _, _), from_ =a))) > 0):
                print("Result within time bound")
            elif timeout(int(time_out) / 1000):
                retransmission_flag = True
                while retransmission_flag:
                    send(('req_curr_config', self), to=olympus)
                    await(some(received(('rcv_curr_config', _))))
                    for rep in current_replicas:
                        print('sending retransmission to : ', str(rep))
                        send(('retransmission', self, request_id, order), to=rep)
                        if await(len(setof(a, received(('retransmission_result', _, _), from_ =a))) > 0):
                            retransmission_flag = False
                        elif timeout(int(time_out) / 1000):
                            continue


    def run():

        logging.info("Running client- clientId: %s clientName: %s",
                     self.nodeId, self.name, extra=Logger.NODE_INFO)

        print("Asking current config from olympus")
        logging.info("Client {clientId: %s, clientName: %s} sending request " +
                     "for CURRENT_CONFIG to olympus {olympusId: %s," +
                     "olympusName: %s} ", self.nodeId, self.name, self.olympus,
                     self.olympus_name, extra=Logger.NODE_INFO)
        
        
        work_load = config_parser.get_config(config_file)[WORK_LOAD + '[' + str(client_no) + ']']
        client_work_load = [each_workload.strip() for each_workload in work_load.split(';')] 
    
        print(client_work_load)
        for order in client_work_load:
            print('order is : ', order)
            if order.startswith('pseudorandom'):
                seed_num_pair_str = re.search(r'\((.*?)\)',order).group(1)
                seed_num_pair_arr = seed_num_pair_str.split(',')
                gen_orders = generate_psedorandom(int(seed_num_pair_arr[0]), int(seed_num_pair_arr[1]))
                print('Hello', gen_orders)
                for gen_order in gen_orders:
                    execute_order(gen_order)
            else:
                execute_order(order)
        while True:
            await(received(('', )))
        return
