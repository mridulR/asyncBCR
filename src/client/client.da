#!/usr/bin/python3
# -*- coding: utf-8 -*-
import sys
import os
import logging
import time
from src.utils import logger
from src.utils import config_parser
from src.utils import command_executor
from random import randint
import re
import random
import nacl.encoding
import nacl.signing

# Configuration keys for client

NUM_OF_CLIENTS = 'num_client'
CLIENT_TIMEOUT = 'client_timeout'
CLIENT_HOSTS = 'client_hosts'
WORK_LOAD = 'workload'
VER_STRATEGY = 'verification_strategy'
VER_MODE = ['VERIFY_EACH_VALUE']


class client(process):

    def setup(config_file, client_no, olympus, olympus_name,
              name, nodeId,):

        self.config = config_parser.get_config(config_file)
        self.time_out = config[CLIENT_TIMEOUT]
        
        # For verifying result value at client.
        # client behaves as tester
        self.running_state = {}
        self.result_map = {}
        
        self.current_replicas = []
        self.current_replicas_name = []
        self.replica_verify_keys = []
        # Setting the logging format for the CONFIG_NODE
        # Default logging is INFO for CONFIG_NODE.
        # Other applicable values - logging.WARN, logging.CRITICAL,
        # logging.ERROR, logging.DEBUG
        # Use respective logging.warn, logging.critical, logging.error,
        # logging.debug

        logger.setLogFormatting(self.name + '.log', logger.getLogDir(),
                                logging.INFO)
        logger.setLogNodeInfo(self.nodeId, self.name)

        # Log the received values

        logging.info("Client received setup - config_file: %s olympus:" +
                     "{Name: %s, Id: %s}", config_file, olympus_name,
                     self.olympus, extra=logger.NODE_INFO)
        return

    def verify_result_proof(result_proofs):
        if is_valid_order_proofs(result_proofs):
            print("Result proof verification passed")
        else:
            print("Result proof verifivation failed")

    def is_valid_order_proofs(result_proofs):
        if len(result_proofs) < 1:
            return False
        result = result_proofs[0][0]
        order = result_proofs[0][1]
        for ind in range(0, len(current_replicas)):
            result_proof = result_proofs[ind]
            pred_result = result_proof[0]
            pred_order = result_proof[1]
            if result != pred_result or order != pred_order:
                return False
            for sec in range(0, ind + 1):
                verify_key = replica_verify_keys[sec]
                try:
                    verify_key.verify(result_proof[2][sec])
                except nacl.exceptions.BadSignatureError:
                    return False
        return True

    def verify_result(result, request_id):
        if VER_MODE[0] == config[VER_STRATEGY]:
            if result == result_map[request_id]:
                print("Passed")
            else:
                print("Failed")
        return
        
    def receive(msg=('rcv_curr_config', replicas, replicas_name, replica_verify_keys), from_=self.olympus):
        if int(len(replicas)) > 0:
            self.current_replicas = replicas
            self.current_replicas_name = replicas_name
            self.replica_verify_keys = replica_verify_keys
        else:
            print("Client received no replica from Olympus for" +
                  "sending requests !!!", extra=logger.NODE_INFO)
        return


    def receive(msg=('result_proof', result_proof, replica_no, request_id)):

        #verify_result_proof(result_proof) ---- > Part of algorithm
        verify_result_proof(result_proof[1])

        # Client acting as tester
        verify_result(result_proof[0], request_id)
        logging.info("Client received result_proof from repli" +
                     "ca {Name: %s, Id:%s}",
                     self.current_replicas_name[int(replica_no)],
                     self.current_replicas[int(replica_no)],
                     extra=logger.NODE_INFO)
        return

    def receive(msg=('retransmission_result', result_proof, replica_no)):
        print ("Received Retransmission result ", replica_no )
        print (result_proof)
        logging.info("Client received retransmission_result from" +
                     "replica { Name:%s, Id:%s}",
                     self.current_replicas_name[int(replica_no)],
                     self.current_replicas[int(replica_no)],
                     extra=logger.NODE_INFO)
        return

    def generate_psedorandom(seed, num):
        orders = []
        supported_operations = ["put", "get", "append", "slice"]
        for ind in range(0, num):
            rand_num = random.randint(seed, seed + num)
            rand_index = rand_num % 4
            rand_oper = supported_operations[rand_index]
            rand_key = "randKey" + str(rand_num)
            rand_value = "randValue" + str(rand_num)
            if rand_index == 0:
                orders.append(rand_oper + "(" + rand_key + "," + rand_value + ")")
            elif rand_index == 1:
                orders.append(rand_oper + "(" + rand_key + ")")
            elif rand_index == 2:
                append_value = "some_rand" + str(random.randint(seed, seed + num))
                orders.append(rand_oper + "(" + rand_key + "," + append_value + ")")
            elif rand_index == 3:
                expected_len = len(rand_value)
                slice_start = random.randint(0, expected_len)
                slice_end = random.randint(0, expected_len)
                orders.append(rand_oper + "(" + rand_key + "," \
                    + str(slice_start) + ":" + str(slice_end) + ")")
        return orders

    def execute_order(order, request_id):
        if len(current_replicas) > 0:
            send(('request_order', self, client_no, request_id, order), \
                to=current_replicas[0])
            if await(len(setof(a, received(('result_proof', _, _, _), from_ =a))) > 0):
                pass
            elif timeout(int(time_out) / 1000):
                retransmission_flag = True
                while retransmission_flag:
                    send(('req_curr_config', self), to=olympus)
                    await(some(received(('rcv_curr_config', _, _, _))))
                    for rep in current_replicas:
                        print('sending retransmission to : ', str(rep))
                        send(('retransmission', self, client_no, request_id, order), to=rep)
                        if await(len(setof(a, received(('retransmission_result', _, _), from_ =a))) > 0):
                            retransmission_flag = False
                        elif timeout(int(time_out) / 1000):
                            continue


    def run():
        logging.info("Running client...", extra=logger.NODE_INFO)

        print("Asking current config from olympus")
        logging.info("Client sending request for CURRENT_" +
                     "CONFIG to olympus {Name: %s, Id: %s} ",
                     self.olympus_name, self.olympus,
                     extra=logger.NODE_INFO)

        send(('req_curr_config', self), to=olympus)
        await(some(received(('rcv_curr_config', _, _, _))))
        
        client_work_load_ind = WORK_LOAD + '[' + str(client_no) + ']'
        if client_work_load_ind in config:
            work_load = config[client_work_load_ind]
            client_work_load = [each_workload.strip() for each_workload in work_load.split(';')] 
    
            for order in client_work_load:
                if order.startswith('pseudorandom'):
                    seed_num_pair_str = re.search(r'\((.*?)\)',order).group(1)
                    seed_num_pair_arr = seed_num_pair_str.split(',')
                    gen_orders = generate_psedorandom(int(seed_num_pair_arr[0]), int(seed_num_pair_arr[1]))
                    for gen_order in gen_orders:
                        print(gen_order)
                        request_id = randint(1, 9000)
                        result_map[request_id] = command_executor.get_result(gen_order, running_state) 
                        execute_order(gen_order, request_id)
                else:
                    print(order)
                    request_id = randint(1, 9000)
                    result_map[request_id] = command_executor.get_result(order, running_state)
                    execute_order(order, request_id)
        while True:
            await(received(('', )))
        return
