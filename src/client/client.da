#!/usr/bin/python3
# -*- coding: utf-8 -*-
import sys
import os
import logging
import time
from src.utils import Logger
from src.utils import config_parser
from src.utils import command_executor
from random import randint
import re
import random

# Configuration keys for client

NUM_OF_CLIENTS = 'num_client'
CLIENT_TIMEOUT = 'client_timeout'
CLIENT_HOSTS = 'client_hosts'
WORK_LOAD = 'workload'
VER_STRATEGY = 'verification_strategy'
VER_MODE = ['VERIFY_EACH_VALUE']


class client(process):

    def setup(config_file, client_no, olympus, olympus_name,
              name, nodeId,):

        self.config = config_parser.get_config(config_file)
        self.time_out = config[CLIENT_TIMEOUT]
        
        # For verifying result value at client.
        # client behaves as tester
        self.running_state = {}
        self.result_map = {}
        
        self.current_replicas = []
        # Setting the logging format for the CONFIG_NODE
        # Default logging is INFO for CONFIG_NODE.
        # Other applicable values - logging.WARN, logging.CRITICAL,
        # logging.ERROR, logging.DEBUG
        # Use respective logging.warn, logging.critical, logging.error,
        # logging.debug

        Logger.setLogFormatting(self.name + '.log', Logger.getLogDir(),
                                logging.INFO)
        Logger.setLogNodeInfo(self.nodeId, self.name)

        # Log the received values

        logging.info("Client {clientId: %s, clientName: %s} received setup - "  +
                     "config_file: %s client_no: %s olympus - {olympusId: %s, " +
                     "olympusName: %s}", self.nodeId,
                     self.name, self.config_file, str(self.client_no),
                     self.olympus, self.olympus_name,
                     extra=Logger.NODE_INFO)
        return

    def verify_result(result, request_id):
        if VER_MODE[0] == config[VER_STRATEGY]:
            if result == result_map[request_id]:
                print("Passed")
            else:
                print("Failed")


    def receive(msg=('rcv_curr_config', replicas), from_=self.olympus):
        if int(len(replicas)) > 0:
            self.current_replicas = replicas
        else:
            print("No replica to send order request to !!!")
        return


    def receive(msg=('result_proof', result_proof, replica_no, request_id)):

        logging.info("client { clientId: %s, clientName: %s} received " +
                     "result_proof from replica {replicaId: %s, replicaName:" +
                     "%s}", self.nodeId, self.name, str(replica_no),
                     str(replica_no), extra=Logger.NODE_INFO)
        #verify_result_proof(result_proof) ---- > Part of algorithm
        
        # Client acting as tester
        verify_result(result_proof[0], request_id)
        return

    def receive(msg=('retransmission_result', result_proof, replica_no)):
        print ("Received Retransmission result ", replica_no )
        print (result_proof)

    def generate_psedorandom(seed, num):
        orders = []
        supported_operations = ['put', 'get', 'append', 'slice']
        for ind in range(0, num):
            rand_num = random.randint(seed, seed + num)
            rand_index = rand_num % 4
            rand_oper = supported_operations[rand_index]
            rand_key = 'randKey' + str(rand_num)
            rand_value = 'randValue' + str(rand_num)
            if rand_index == 0:
                orders.append(rand_oper + '(' + rand_key + ',' + rand_value + ')')
            elif rand_index == 1:
                orders.append(rand_oper + '(' + rand_key + ')')
            elif rand_index == 2:
                append_value = 'append_rand' + str(random.randint(seed, seed + num))
                orders.append(rand_oper + '(' + rand_key + ',' + append_value + ')')
            elif rand_index == 3:
                expected_len = len(rand_value)
                slice_start = random.randint(0, expected_len)
                slice_end = random.randint(0, expected_len)
                orders.append(rand_oper + '(' + rand_key + ',' \
                    + str(slice_start) + ':' + str(slice_end) + ')')
        return orders

    def execute_order(order, request_id):
        if len(current_replicas) > 0:
            send(('request_order', self, request_id, order), \
                to=current_replicas[0])
            if await(len(setof(a, received(('result_proof', _, _, _), from_ =a))) > 0):
                pass
            elif timeout(int(time_out) / 1000):
                retransmission_flag = True
                while retransmission_flag:
                    send(('req_curr_config', self), to=olympus)
                    await(some(received(('rcv_curr_config', _))))
                    for rep in current_replicas:
                        print('sending retransmission to : ', str(rep))
                        send(('retransmission', self, request_id, order), to=rep)
                        if await(len(setof(a, received(('retransmission_result', _, _), from_ =a))) > 0):
                            retransmission_flag = False
                        elif timeout(int(time_out) / 1000):
                            continue


    def run():

        logging.info("Running client- clientId: %s clientName: %s",
                     self.nodeId, self.name, extra=Logger.NODE_INFO)

        logging.info("Client {clientId: %s, clientName: %s} sending request " +
                     "for CURRENT_CONFIG to olympus {olympusId: %s," +
                     "olympusName: %s} ", self.nodeId, self.name, self.olympus,
                     self.olympus_name, extra=Logger.NODE_INFO)

        send(('req_curr_config', self), to=olympus)
        await(some(received(('rcv_curr_config', _))))
        
        client_work_load_ind = WORK_LOAD + '[' + str(client_no) + ']'
        if client_work_load_ind in config:
            work_load = config[client_work_load_ind]
            client_work_load = [each_workload.strip() for each_workload in work_load.split(';')] 
    
            for order in client_work_load:
                if order.startswith('pseudorandom'):
                    seed_num_pair_str = re.search(r'\((.*?)\)',order).group(1)
                    seed_num_pair_arr = seed_num_pair_str.split(',')
                    gen_orders = generate_psedorandom(int(seed_num_pair_arr[0]), int(seed_num_pair_arr[1]))
                    for gen_order in gen_orders:
                        print(gen_order)
                        request_id = randint(1, 9000)
                        result_map[request_id] = command_executor.get_result(gen_order, running_state) 
                        execute_order(gen_order, request_id)
                else:
                    print(order)
                    request_id = randint(1, 9000)
                    result_map[request_id] = command_executor.get_result(order, running_state)
                    execute_order(order, request_id)
        while True:
            await(received(('', )))
        return
