#!/usr/bin/python3
# -*- coding: utf-8 -*-
import sys
import os
import logging
import time
import re
import json
import nacl.encoding
import nacl.signing
import nacl.hash
import time
from src.utils import config_parser
from src.utils import command_executor
from src.utils import logger

REPLICA_HOSTS = "replica_hosts"
FAILURES_TO_TOLERATE = "t"
HEAD_TIMEOUT = "head_timeout"
NON_HEAD_TIMEOUT = "nonhead_timeout"
HASHER = nacl.hash.sha256
current_milli_time = lambda: int(round(time.time() * 1000))

class replica(process):
    """ An implementation to handle all the replicas."""

    def setup(config_file, replica_no, replicas, replicas_name, olympus,
              oly_verify_key, replica_verify_keys, sign_key):
        """ Setting up the replica based on configuration."""

        # client last opearation mapping
        self.client_last_op = {}

        # state of replica - ACTIVE and IMMUTABLE
        self.state = "ACTIVE"

        # configuration of replica
        self.configuration_num = 0


        # cache for storing result and result proof
        self.cache = {}

        #check-pointing
        self.opr_count_chk_pt = 0
        self.checkpoint_ind = 0
        self.checkpoint = {}

        # Testing
        self.global_operation = ""
        self.injected_get_operation = {}
        self.injected_change_result = {}
        self.injected_drop_result = {}

        # Triggers
        self.client_direct_msg_trigger = {}
        self.client_fwd_rqst_trigger = {}
        self.client_shuttle_trigger = {}
        self.client_result_shuttle_trigger = {}
        self.checkpoint_trigger = {}
        self.completed_checkpoint_trigger = {}
        self.wedge_request_trigger = {}
        self.new_configuration_trigger = {}
        self.get_running_state_trigger = {}
        self.catch_up_trigger = {}

        # Trigger Counter
        self.client_direct_msg_counter = {}
        self.client_fwd_rqst_counter = {}
        self.client_shuttle_counter = {}
        self.client_result_shuttle_counter = {}
        self.checkpoint_counter = 0
        self.completed_checkpoint_counter = 0
        self.wedge_request_counter = 0
        self.get_running_state_counter = 0
        self.catch_up_counter = 0

        # current_slot updated only by head replica
        self.current_slot = 0

        # running state of replica
        self.running_state = {}

        # history of replica
        self.history = []

        # Head-Timeout Counter
        self.head_time_out_counter = {}

        # Non-Head Timeout Counter
        self.non_head_time_out_counter = {}


        # Update next and previous replica by each replica
        self.num_of_replicas = len(replicas)
        if replica_no == 0:
            self.prev = None
            self.me = replicas[0]
            self.next_r = replicas[1]

            # Setting log file for head Node
            logger.setLogFormatting(replicas_name[replica_no] + '.log',
                                    logger.getLogDir(), logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values
            logging.info("HEAD received setup: { Config_file: %s," +
                         "Replicas_list: %s Replicas_name: %s, Olympus: %s }",
                         config_file, replicas, replicas_name, olympus,
                         extra=logger.NODE_INFO)

        elif replica_no == len(replicas) - 1:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = None

            # Setting log file for tail Node
            logger.setLogFormatting(replicas_name[replica_no] + '.log',
                                    logger.getLogDir(), logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values
            logging.info("TAIL received setup: { Config_file: %s," +
                         "Replicas_list: %s Replicas_name: %s, Olympus: %s }",
                         config_file, replicas, replicas_name, olympus,
                         extra=logger.NODE_INFO)

        else:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = replicas[replica_no + 1]

            # Setting log file for other replica Node
            logger.setLogFormatting(replicas_name[replica_no] + '.log',
                                    logger.getLogDir(), logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values
            logging.info("Replica received setup: { Config_file: %s," +
                         "Replicas_list: %s Replicas_name: %s, Olympus: %s }",
                         config_file, replicas, replicas_name, olympus,
                         extra=logger.NODE_INFO)

        # Setting timeout for replica head and non-head
        self.config = config_parser.get_config(config_file)
        self.head_time_out = config[HEAD_TIMEOUT]
        self.non_head_time_out = config[NON_HEAD_TIMEOUT]

        if prev == None:
            self.time_out = head_time_out
            logging.info("HEAD timeout value: %s ms", str(head_time_out),
                         extra=logger.NODE_INFO)
        else:
            self.time_out = non_head_time_out
            logging.info("Replica timeout value: %s ms",
                         str(non_head_time_out), extra=logger.NODE_INFO)
        return

    def init_triggers_counters():

        # Head-Timeout Counter
        self.head_time_out_counter = {}

        # Non-Head Timeout Counter
        self.non_head_time_out_counter = {}

        # Triggers
        self.client_direct_msg_trigger = {}
        self.client_fwd_rqst_trigger = {}
        self.client_shuttle_trigger = {}
        self.client_result_shuttle_trigger = {}
        self.checkpoint_trigger = {}
        self.completed_checkpoint_trigger = {}
        self.wedge_request_trigger = {}
        self.new_configuration_trigger = {}
        self.get_running_state_trigger = {}
        self.catch_up_trigger = {}

        # Trigger Counter
        self.client_direct_msg_counter = {}
        self.client_fwd_rqst_counter = {}
        self.client_shuttle_counter = {}
        self.client_result_shuttle_counter = {}
        self.checkpoint_counter = 0
        self.completed_checkpoint_counter = 0
        self.wedge_request_counter = 0
        self.get_running_state_counter = 0
        self.catch_up_counter = 0

    def generic_operation_parser(operation):
        func = {}
        start = operation.find("(")
        end = operation.find(")")
        func["name"] = operation
        args = []
        func["args"] = args
        if start == -1 or end == -1:
            print("Expecting a function !!!")
            return func
        op_type = operation[:start]
        func["name"] = op_type
        args = operation[start+1 : end]
        args = args.replace(' ', '')
        args = args.split(',')
        func["args"] = args
        return func

    def trigger_parser(trigger):
        function_list=[]
        trigger= trigger.replace(' ','')
        index = trigger.find("),")
        if index == -1:
            return function_list
        function_list.append(trigger[:index+1])
        function_list.append(trigger[index+2:])
        return function_list

    def set_failure_triggers():
        """ Setting up the injection point for each replica after reading the
            configuration from the config file.based on configuration. """

        for key, value in config.items():
            trigger_failure_list = []
            if key.startswith('failures'):
                config_replica = re.search(r'\[(.*?),(.*?)\]', key)
                config_num = int(config_replica.group(1))
                replica = int(config_replica.group(2))

                if config_num == configuration_num and replica == replica_no:
                    trigger_failures = [each.strip() for each in value.split(';')]
                    for trigg_fail in trigger_failures:
                        if trigg_fail.startswith("client_request"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0] + "_" + trig["args"][1]
                            operation = trigger[1]
                            client_direct_msg_trigger[key] = operation
                        elif trigg_fail.startswith("forwarded_request"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0] + "_" + trig["args"][1]
                            operation = trigger[1]
                            client_fwd_rqst_trigger[key] = operation
                        elif trigg_fail.startswith("shuttle"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0] + "_" + trig["args"][1]
                            operation = trigger[1]
                            client_shuttle_trigger[key] = operation
                        elif trigg_fail.startswith("result_shuttle"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0] + "_" + trig["args"][1]
                            operation = trigger[1]
                            client_result_shuttle_trigger[key] = operation
                        elif trigg_fail.startswith("checkpoint"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0]
                            operation = trigger[1]
                            checkpoint_trigger[key] = operation
                        elif trigg_fail.startswith("completed_checkpoint"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0]
                            operation = trigger[1]
                            completed_checkpoint_trigger[key] = operation
                        elif trigg_fail.startswith("wedge_request"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0]
                            operation = trigger[1]
                            wedge_request_trigger[key] = operation
                        elif trigg_fail.startswith("new_configuration"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0]
                            operation = trigger[1]
                            new_configuration_trigger[key] = operation
                        elif trigg_fail.startswith("get_running_state"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0]
                            operation = trigger[1]
                            get_running_state_trigger[key] = operation
                        elif trigg_fail.startswith("catch_up"):
                            trigger = trigger_parser(trigg_fail)
                            trig = generic_operation_parser(trigger[0])
                            key = trig["args"][0]
                            operation = trigger[1]
                            catch_up_trigger[key] = operation

    return

    def combine_result_proof(result, order, predecessor_results, isinjected):
        """ Updates the result_proof with it's own sign key on top of the
            predecessor's (the one before in the chain) result_proof. It hashes
            the result before signing and then only sends the result_proof
            over a shuttle in forward/backward direction. """

        msg = 16 * str.encode(result)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)

        if isinjected == True:
            fake_key = nacl.signing.SigningKey.generate()
            signed = fake_key.sign(digest)
        else:
            signed = sign_key.sign(digest)

        predecessor_results.append(signed)
        return (result, order, replica_no, predecessor_results)

    def combine_order_proof(slot_no, order_string, predecessor_orders, invalid_order_sign):
        """ Updates the order_proof received from predesessor replica, with
            it's own sign key on top of it and then sends the order_proof. A
            predecessor is the replica that comes immediately before it, in the
            chain. """

        tup = (str(slot_no), order_string, str(replica_no))
        if invalid_order_sign == True:
            fake_key = nacl.signing.SigningKey.generate()
            signed = fake_key.sign(str.encode(str(tup)))
        else:
            signed = sign_key.sign(str.encode(str(tup)))
        predecessor_orders.append(signed)
        return (slot_no, order_string, replica_no, predecessor_orders)

    def create_order_proof(slot_no, order_string, isinjected):
        """ HEAD replica creates the order_proof which is forwarded alongwith
            shuttle to the next replica in chain. Other replica's append their
            order_proof to this and send along the chain. The tail replica
            sends the order_proof on shuttle along the chain in opposite
            direction. """

        tup = (str(slot_no), order_string, str(replica_no))
        if isinjected == True:
            fake_key = nacl.signing.SigningKey.generate()
            signed = fake_key.sign(str.encode(str(tup)))
        else:
            signed = sign_key.sign(str.encode(str(tup)))
        predecessor_order_proofs = [signed]
        return (slot_no, order_string, replica_no, predecessor_order_proofs)

    def create_result_proof(result, order, isinjected):
        """ HEAD replica creates the result_proof which is forwarded alongwith
            shuttle to the next replica in chain. Other replica's append their
            result_proof to this and send along the chain. The tail replica
            sends the result_proof on shuttle along the chain in opposite
            direction as well as to the client. """

        msg = 16 * str.encode(result)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        if isinjected == True:
            fake_key = nacl.signing.SigningKey.generate()
            signed = fake_key.sign(digest)
        else:
            signed = sign_key.sign(digest)
        return (result, order, replica_no, [signed])

    def is_valid_result_proof(result_proofs, cal_result):
        """ Validates if the result_proof is correct or not.
               -If the result doesn't match the predecessor replica's result
                then returns false.
               -If the order is not present in the predecessor's order.
                then returns false.
               -If the sign verification of the result_proof with predecessor
                replica's verify key fails, then return false. is not present
                in the predecessor's order then returns false.
               -If the result proof size is zero then return false.
               -otherwise return TRUE. """

        if len(result_proofs) < 1:
            logging.error("MISBEHAVIOUR: Empty Result Proof ",
                          extra=logger.NODE_INFO)
            return False


        result = result_proofs[0][0]
        order = result_proofs[0][1]
        for ind in range(0, len(replicas)):
            try:
                result_proof = result_proofs[ind]
                pred_result = result_proof[0]
                pred_order = result_proof[1]
                if result != pred_result or order != pred_order:
                    logging.error("MISBEHAVIOUR: Conflicting result or OrderNo " +
                              "does not match. {Result: %s, OrderNo: %s}" +
                              "{Predecessor Replica Result: %s ," +
                              "Predecessor Replica OrderNo: %s}", result,
                              order, pred_result, pred_order,
                              extra=logger.NODE_INFO)
                    return False
                for sec in range(0, ind + 1):
                    verify_key = replica_verify_keys[sec]
                    try:
                        verify_key.verify(result_proof[3][sec])
                    except nacl.exceptions.BadSignatureError:
                        logging.error("MISBEHAVIOUR: Bad signature error in " +
                                  "Result Proof", extra=logger.NODE_INFO)
                        return False
            except IndexError:
                return False
        return True

    def is_valid_order_proofs(order_proofs):
        """ Validates if the order_proof is correct or not.
              -If the slot is not present in the predecessor replica's slot
               then returns false.
              -If the order is not present in the predecessor's order.
               then returns false.
              -If the sign verification of the order_proof with predecessor
               replica's verify key fails, then return false.
               -If the order proof size is zero then return false.
              -otherwise TRUE. """

        if len(order_proofs) < 1:
            logging.error("MISBEHAVIOUR: Empty Order Proof ",
                          extra=logger.NODE_INFO)
            return False
        slot = order_proofs[0][0]
        order = order_proofs[0][1]
        if slot in cache:
            logging.error("MISBEHAVIOUR: Conflicting slot. Slot already " +
                          "present in cache. {SlotNo: %s}", slot,
                          extra=logger.NODE_INFO)
            return False
        for ind in range(0, replica_no):
            order_proof = order_proofs[ind]
            pred_slot = order_proof[0]
            pred_order = order_proof[1]
            if slot != pred_slot or order != pred_order:
                logging.error("MISBEHAVIOUR: Unknown slot or OrderNo not " +
                              "present in Order_Proof. {SlotNo: %s, OrderNo:" +
                              " %s} {Predecessor Replica Slot No: %s ," +
                              "Predecessor Replica Order No: %s}", slot, order,
                              pred_slot, pred_order, extra=logger.NODE_INFO)
                return False
            for sec in range(0, ind + 1):
                verify_key = replica_verify_keys[sec]
                try:
                    verify_key.verify(order_proof[3][sec])
                except nacl.exceptions.BadSignatureError:
                    logging.error("MISBEHAVIOUR: Bad signature error in " +
                                  "Order Proof", extra=logger.NODE_INFO)

                    return False
        return True

    def get_slot_order(order_proof):
        """ Fetches the slot from the first verified order_proof. """
        first_order_st = order_proof[0]
        return first_order_st[0], first_order_st[1]

    # Retransmission ack from head to replica
    def receive(msg=('retransmission_ack', order_id), from_=replicas[0]):
        """ Receives the retransmission acknowledgement from the HEAD to cancel
            the timeout of itself. """

        if prev != None:
            print("Received ack from head for retransmission, ",
                  "Cancelling timeout")
            logging.info("Received ack from head for retransmission, " +
                         "cancelling timeout", extra=logger.NODE_INFO)

    # Eventually head will deal with re-transmission from replicas
    def receive(msg=('retransmission_to_head', client, client_no, replica,
                order_id, order,)):
        """ Receives the retransmission message from the CLIENT. If the result
            is not present in the cache then it will forward the request to the
            HEAD to handle it. It also starts a time waiting for HEAD's ACK. If
            the acknowledgement is not received then then trigger
            reconfiguration to olympus. """

        if state == "IMMUTABLE":
            return

        if self.prev == None:

            client_last_op[client_no] = order

            if client_no not in client_fwd_rqst_counter:
                client_fwd_rqst_counter[client_no] = 0
            client_fwd_rqst_counter[client_no] += 1
            print('Retransmission request forwarded from replica ......')
            logging.info("Retransmission request forwarded from replica" +
                         "......", extra=logger.NODE_INFO)
            try:
                if order_id in cache and len(cache[order_id]) == 2:
                    send(('retransmission_result', cache[order_id], replica_no, order_id,),
                         to=client)

                    logging.info("Sending retransmission_ack ACK: {orderId: %s}",
                                 str(order_id), extra=logger.NODE_INFO)

                    send(('retransmission_ack', order_id), to=replica)

                elif order_id in cache and len(cache[order_id]) == 1:
                    if await(len(cache[order_id]) == 2):
                        send(('retransmission_result', cache[order_id],
                             replica_no, order_id,), to=client)
                        send(('retransmission_ack', order_id), to=replica)

                    elif timeout(int(time_out) / 1000):
                        handle_client_req_at_head(client, client_no, order_id,
                                                  order, None, None)
                        if await(len(cache[order_id]) == 2):
                            send(('retransmission_result', cache[order_id],
                                  replica_no, order_id,), to=client)
                            send(('retransmission_ack', order_id), to=replica)

                        elif timeout(int(time_out) / 1000):
                            print("Request of reconfiguration from head")
                            logging.info("Request of reconfiguration from head",
                                         extra=logger.NODE_INFO)
                else:
                    handle_client_req_at_head(client, client_no, order_id, order,
                                             None, None)
                    if await(len(cache[order_id]) == 2):
                        send(('retransmission_result', cache[order_id], \
                                replica_no, order_id,), to=client)
                        send(('retransmission_ack', order_id), to=replica)

                    elif timeout(int(time_out) / 1000):
                        print("Request of reconfiguration from head")
                        logging.info("Request of reconfiguration from head", \
                                                    extra=logger.NODE_INFO)
        
            except KeyError:
                print("Cache was reset during reconfig, hence client should retry")
        else:
            print("Only head has to eventually deal with re transmission request")

    def handle_client_req_at_head(client, client_no, unique_order_ide,
                                  order_req, triggers, keys):
        """ Handles the client order request. It assigns a slot to order and
            then create the order_proof and result_proof which is forwarded
            along the chain. """

        print("Received order request at head : ", order_req)
        
        current_slot = current_slot + 1

        # No need to verify order proof at head
        order_proofs = []

        injected_slot = current_slot
        invalid_order_sign = False
        invalid_result_sign = None 
        injected_result = None
        injected_extra_op = None
        injected_drop_result_statement = None
        injected_drop = None

        if triggers != None:
            if is_slot_injected(triggers, keys ):
                injected_slot = current_slot + 1
                logging.info("HEAD incremented slot. { New Current_slot: %s }",
                              str(injected_slot), extra=logger.NODE_INFO)

            if is_invalid_order_sign_injected(triggers, keys):
                 invalid_order_sign = True

            if is_invalid_result_sign_injected(triggers, keys):
                invalid_result_sign = True

            if is_result_injected(triggers, keys):
                injected_result = "OK"

            if is_extra_op_injected(triggers, keys ):
                injected_extra_op = "put('a','a')"

            if is_drop_result_statement_injected(triggers, keys):
                injected_drop_result_statement = True

            if is_sleep_injected(triggers, keys):
                print("Sleep injected")

            if is_drop_injected(triggers, keys ):
                injected_drop = True

            if is_history_truncated_injected(triggers, keys ):
                print("Truncated History")

        if injected_extra_op != None:
            extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

        # Order proof is a list of tuples (slot, order, replica, [digtal signs
        # of preceding])
        order_proofs.append(create_order_proof(injected_slot, order_req, invalid_order_sign))
        result = command_executor.get_result(order_req, running_state)

        if injected_result != None:
            result = injected_result
        if result != None:
            cache[unique_order_ide] = [result]
            result_proof = []
            result_proof.append(create_result_proof(result, order_req, invalid_result_sign))

            if injected_drop_result_statement != None:
                result_proof = []

            logging.info("HEAD sending FORWARD_SHUTTLE to next replica in " +
                         "chain. { OrderNo: %s, OrderRequest: %s, " +
                         "NextReplicaName: %s ClientNo: %s, RESULT: %s }",
                         unique_order_ide, str(order_req),
                         replicas_name[int(replica_no)+1], str(client_no),
                         result, extra=logger.NODE_INFO)
            history.append(order_proofs)
            if injected_drop == None:
                head_time_out_counter[unique_order_ide] = current_milli_time()
                print("Head current time - ", head_time_out_counter[unique_order_ide])
                send(('forward_shuttle', client, client_no, unique_order_ide,
                      order_proofs, result_proof,), to=next_r)

    def set_global_operation(order):
        global_operation = order

    def get_injected_drop_stmt(client_no, msg_count):
        key = str(client_no)
        if key in injected_drop_result.keys():
            val = injected_drop_result[key]
            if int(val) + 1 == int(msg_count):
                return True
        return False

    def get_injected_result(client_no, msg_count):
        key = str(client_no)
        if key in injected_change_result.keys():
            val = injected_change_result[key]
            if int(val) + 1 == int(msg_count):
                return "OK"
        return None

    def get_injected_operation(client_no, msg_count):
        key = str(client_no)
        if key in injected_get_operation.keys():
            val = injected_get_operation[key]
            if int(val) + 1 == int(msg_count):
                return "get('x')"
        return global_operation

    def set_trigger_for_change_operation(client_no, msg_num):
        key = str(client_no)
        injected_get_operation[key] = msg_num

    def set_trigger_for_change_result(client_no, msg_num):
        key = str(client_no)
        injected_change_result[key] = msg_num

    def set_trigger_for_drop_result_stmt(client_no, msg_num):
        key = str(client_no)
        injected_drop_result[key] = msg_num

    def trigger_failure_injection_for_shuttle(client_no, msg_count_by_client):
        key = str(client_no) + "_" + str(msg_count_by_client)
        if str(key) in client_shuttle_trigger:
            val = client_shuttle_trigger[key]
            if val == "change_operation":
                set_trigger_for_change_operation(client_no, msg_count_by_client)
            elif val == "change_result":
                set_trigger_for_change_result(client_no, msg_count_by_client)
            elif val == "drop_result_stmt":
                set_trigger_for_drop_result_stmt(client_no,
                                                 msg_count_by_client)

    def extract_slot_order_map_from_history(rep_history):
        slot_order_map = {}
        for list_order_proofs in rep_history:
            for order_proofs in list_order_proofs:
                slot_order_map[order_proofs[0]] = order_proofs[1]
        return slot_order_map


    def start_check_pointing():
        if self.prev == None:
            chk_point_proof = {}

            '''msg = 16 * str.encode(str(replica_no))
            digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
            signed = sign_key.sign(digest)'''
            chk_point_proof[replica_no] = extract_slot_order_map_from_history(history)
            print("checkpointing started *********************** ", len(chk_point_proof))

            checkpoint_counter += 1
            checkpoint_key = str(checkpoint_counter)
            triggers = ["checkpoint"]
            keys = [checkpoint_key]

            # Injection Code Start
            injected_extra_op = None
            injected_drop = None

            if triggers != None:
                if is_extra_op_injected_checkpoint(triggers, keys ):
                    injected_extra_op = "put('a','a')"

                if is_sleep_injected_checkpoint(triggers, keys):
                    print("Sleep injected")

                if is_drop_injected_checkpoint(triggers, keys ):
                    injected_drop = True

                if is_history_truncated_injected_checkpoint(triggers, keys ):
                    print("Truncated History")

            if injected_extra_op != None:
                extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

            if injected_drop == None:
                send(('chk_point_frwd', chk_point_proof, checkpoint_ind + 1,), to=next_r)

            return

    def get_slot_order_intersection(slot_order_map_1, slot_order_map_2):
        result = {}
        for key in slot_order_map_1.keys():
            if key in slot_order_map_2:
                val_1 = slot_order_map_1[key]
                val_2 = slot_order_map_2[key]
                if val_1 == val_2:
                    result[key] = val_1
                else:
                    return None
        return result

    def get_Min_Check_Pt_Map(chk_point_proof):
        if chk_point_proof == None:
            return None
        if len(chk_point_proof) < 2:
            return chk_point_proof

        result = {}

        result = chk_point_proof[0]
        for ind in range(1, len(replicas)):
            result = get_slot_order_intersection(result, chk_point_proof[ind])
        return result

    def get_result_history(rslt_chk_pt, history):
        result = []
        for his in history:
            temp = []
            for order_proofs in his:
                slot_no = order_proofs[0]
                order = order_proofs[1] ## No need to verify again
                if slot_no not in rslt_chk_pt.keys():
                    temp.append(order_proofs)
            if len(temp) != 0:
                result.append(temp)
        return result


    def is_valid_chk_pt_proof(chk_point_proof, replica_no):
        if len(chk_point_proof) < 2:
            return True
        result_slot_order_map = chk_point_proof[0]
        for ind in range(1, replica_no):
            verify_key = replica_verify_keys[ind]
            curr_order_ = chk_point_proof[ind]

            curr_slot_order_map = extract_slot_order_map_from_history(history)
            result_slot_order_map = get_slot_order_intersection(result_slot_order_map, curr_slot_order_map)
            if result_slot_order_map == None:
                return False
            '''try:
                print("roku2")
                verify_key.verify(chk_point_proof[ind][1])
                print("roku3")
            except nacl.exceptions.BadSignatureError:
                print("roku4")
                return False
            except IndexError:
                print("roku5")
                return False'''
        return True

    def receive(msg=('chk_point_rslt', chk_point_proof, chk_point_index,), from_=self.next_r):
        rslt_chk_pt = get_Min_Check_Pt_Map(chk_point_proof)
        rslt_history = get_result_history(rslt_chk_pt, history)

        ## update values
        checkpoint_ind = chk_point_index
        checkpoint.update(rslt_chk_pt)
        history = rslt_history

        # Injection Code Start
        completed_checkpoint_counter += 1
        completed_checkpoint_key = str(completed_checkpoint_counter)
        triggers = ["completed_checkpoint"]
        keys = [completed_checkpoint_key]
        
        injected_extra_op = None
        injected_drop = None
        injected_drop_checkpt_stmnts = None

        if triggers != None:
            if is_drop_checkpt_stmts_injected_rslt_completed_checkpoint(triggers, keys ):
                injected_drop_checkpt_stmnts = True

            if is_extra_op_injected_rslt_completed_checkpoint(triggers, keys ):
                injected_extra_op = "put('a','a')"

            if is_sleep_injected_rslt_completed_checkpoint(triggers, keys):
                print("Sleep injected")

            if is_drop_injected_rslt_completed_checkpoint(triggers, keys ):
                injected_drop = True

            if is_history_truncated_injected_rslt_completed_checkpoint(triggers, keys ):
                print("Truncated History")

        if injected_extra_op != None:
            extra_op_ret = command_executor.get_result(injected_extra_op, running_state)
        
        if injected_drop_checkpt_stmnts != None:
            quorum = len(replicas) + 1
            key = 0
            for key in range(0, quorum + 1):
                del chk_point_proof[key]

        print("checkpont Completed ***********************")
        print(checkpoint_ind, " - ", client_last_op)
        print(checkpoint)
        print("History : ")
        for his in history:
            for order_proofs in his:
                print("slot - ", order_proofs[0], " order - ", order_proofs[1], \
                    " replica - ", order_proofs[2], "  sign - ", len(order_proofs[3]))
        print("checkpont return Success ***********************")
        if self.prev != None:
            send(('chk_point_rslt', chk_point_proof, chk_point_index,), to=prev)


    def receive(msg=('chk_point_frwd', chk_point_proof, chk_point_index,), from_=self.prev):
        if checkpoint_ind + 1 == chk_point_index:
            if is_valid_chk_pt_proof(chk_point_proof, replica_no):

                '''msg = 16 * str.encode(str(replica_no))
                digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
                signed = sign_key.sign(digest)'''
                chk_point_proof[replica_no] = extract_slot_order_map_from_history(history)
                print("valid checkpointing received ******************** ", len(chk_point_proof))
                if next_r != None:

                    checkpoint_counter += 1
                    checkpoint_key = str(checkpoint_counter)
                    triggers = ["checkpoint"]
                    keys = [checkpoint_key]

                    # Injection Code Start
                    injected_extra_op = None
                    injected_drop = None

                    if triggers != None:
                        if is_extra_op_injected_checkpoint(triggers, keys ):
                            injected_extra_op = "put('a','a')"

                        if is_sleep_injected_checkpoint(triggers, keys):
                            print("Sleep injected")

                        if is_drop_injected_checkpoint(triggers, keys ):
                            injected_drop = True

                        if is_history_truncated_injected_checkpoint(triggers, keys ):
                            print("Truncated History")

                    if injected_extra_op != None:
                        extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

                    if injected_drop == None:
                      send(('chk_point_frwd', chk_point_proof, chk_point_index,), to=next_r)

                else:

                    checkpoint_counter += 1
                    checkpoint_key = str(checkpoint_counter)
                    completed_checkpoint_counter += 1
                    completed_checkpoint_key = str(completed_checkpoint_counter)
                    triggers = ["checkpoint", "completed_checkpoint"]
                    keys = [checkpoint_key, completed_checkpoint_key]

                    # Injection Code Start
                    injected_extra_op = None
                    injected_drop = None
                    injected_drop_checkpt_stmnts = None

                    if triggers != None:
                        if is_drop_checkpt_stmts_injected_completed_checkpoint(triggers, keys ):
                            injected_drop_checkpt_stmnts = True

                        if is_extra_op_injected_completed_checkpoint(triggers, keys ):
                            injected_extra_op = "put('a','a')"

                        if is_sleep_injected_completed_checkpoint(triggers, keys):
                            print("Sleep injected")

                        if is_drop_injected_completed_checkpoint(triggers, keys ):
                            injected_drop = True

                        if is_history_truncated_injected_completed_checkpoint(triggers, keys ):
                            print("Truncated History")

                    if injected_extra_op != None:
                        extra_op_ret = command_executor.get_result(injected_extra_op, running_state)
                    
                    if injected_drop_checkpt_stmnts != None:
                        quorum = len(replicas) + 1
                        key = 0
                        for key in range(0, quorum + 1):
                            del chk_point_proof[key]

                    rslt_chk_pt = get_Min_Check_Pt_Map(chk_point_proof)
                    rslt_history = get_result_history(rslt_chk_pt, history)

                    ## update values
                    checkpoint_ind = chk_point_index
                    checkpoint.update(rslt_chk_pt)
                    history = rslt_history

                    '''print("checkpont return Completed ***********************")
                    print(checkpoint)
                    print(history)
                    print("checkpont return Success ***********************")'''
                    
                    if injected_drop == None:
                        send(('chk_point_rslt', chk_point_proof, chk_point_index,), to=prev)

            else:
                print("checkpointing failed verification, invoke reconfiguration")

    def receive(msg=('new_configuration', config_ind, chk_pt_ind, chk_pt, run_state), from_=olympus):
        print("Received new configuration ======, ", chk_pt)
        self.configuration_num = config_ind
        self.history = []
        self.opr_count_chk_pt = 0
        self.checkpoint_ind = chk_pt_ind
        self.checkpoint = chk_pt
        self.client_last_op = {}
        self.current_slot = 0
        self.running_state = {}
        #self.cache = {}

        #for slot in sorted(checkpoint.keys()):
        #    result = command_executor.get_result(checkpoint[slot], running_state)
        #    current_slot = slot
        
        running_state = run_state
        current_slot = sorted(checkpoint.keys())[-1]

        init_triggers_counters()
        set_failure_triggers()
        print("Resetting triggers")
        

        self.state = "ACTIVE"
        print("sending new config ack to olympus")
        
        # Injection Code Start
        injected_extra_op = None
        injected_drop = None
       
        if configuration_num in new_configuration_trigger.keys():

            if is_extra_op_injected_new_configuration():
                injected_extra_op = "put('a','a')"

            if is_sleep_injected_new_configuration():
                print("Sleep injected")

            if is_drop_injected_new_configuration():
                injected_drop = True

            if is_history_truncated_injected_new_configuration():
                print("Truncated History")

        if injected_extra_op != None:
            extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

        if injected_drop == None:
            send(('new_config_done', replica_no), to=olympus)
            self.cache = {} 

        send(('new_config_done', replica_no), to=olympus)
        self.cache = {}

        return 

    def build_slot_order_map(history):
        slot_order_map = {}
        for order_proofs in history:
            slot_no = order_proofs[0][0]
            operation = order_proofs[0][1]
            slot_order_map[slot_no]= operation
        return slot_order_map

    def catch_longest_hist(slot_order_map, long_hist):
        for key in long_hist.keys():
            if key not in slot_order_map:
                command_executor.get_result(long_hist[key], running_state)
        return running_state

    def receive(msg=('catch_up', long_hist), from_=olympus):
        print("sending caught up to olympus")
        slot_order_map = build_slot_order_map(history)
        catched_running_state = catch_longest_hist(slot_order_map, long_hist)
        catched_running_state_str = json.dumps(catched_running_state)
        print("catched_running_state_str ********* ", catched_running_state_str)
        msg = 16 * str.encode(catched_running_state_str)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        
        catch_up_counter += 1
        catch_up_key = str(catch_up_counter)
        triggers = ["catch_up"]
        keys = [catch_up_key]
    
        # Injection Code Start
        injected_extra_op = None
        injected_drop = None

        if triggers != None:
            if is_extra_op_injected_catch_up(triggers, keys ):
                injected_extra_op = "put('a','a')"

            if is_sleep_injected_catch_up(triggers, keys):
                print("Sleep injected")

            if is_drop_injected_catch_up(triggers, keys ):
                injected_drop = True

            if is_history_truncated_injected_catch_up(triggers, keys ):
                print("Truncated History")

        if injected_extra_op != None:
            extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

        if injected_drop == None:
            send(('caught_up', replica_no, digest), to=olympus)

        return 

    def receive(msg=('get_running_state',), from_=olympus):
        print("Sending state to olympus")
        send(('rcv_running_state',replica_no, running_state), to=olympus)

    def receive(msg=('activate',), from_=olympus):
        self.state = "ACTIVE"
        print("Setting state as active")
        send(('ack_activate',replica_no), to=olympus)
        return 

    def receive(msg=('wedge',), from_=olympus):
        print("wedge statement received from olympus")
        self.state = "IMMUTABLE"

        wedge_request_counter += 1
        wedge_key = str(wedge_request_counter)
        triggers = ["wedge_request"]
        keys = [wedge_key]
        
        # Injection Code Start
        injected_extra_op = None
        injected_drop = None

        if triggers != None:
            if is_extra_op_injected_wedge(triggers, keys ):
                injected_extra_op = "put('a','a')"

            if is_sleep_injected_wedge(triggers, keys):
                print("Sleep injected")

            if is_drop_injected_wedge(triggers, keys ):
                injected_drop = True

            if is_history_truncated_injected_wedge(triggers, keys ):
                print("Truncated History")

        if injected_extra_op != None:
            extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

        if injected_drop == None:
            send(('wedge_resp', replica_no, checkpoint_ind, checkpoint, history, client_last_op), to=olympus) 

        return

    def is_order_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("change_operation"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("change_operation"):
                    return True
        return False

    def is_result_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("change_result"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("change_result"):
                    return True
        return False

    def is_slot_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("increment_slot"):
                    logging.info("HEAD will incremented slot. { Current_slot: %s }",
                                  str(current_slot), extra=logger.NODE_INFO)
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("increment_slot"):
                    logging.info("HEAD will incremented slot. { Current_slot: %s }",
                                  str(current_slot), extra=logger.NODE_INFO)
                    return True
        return False

    def is_invalid_order_sign_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("invalid_order_sig"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("invalid_order_sig"):
                    return True
        return False

    def is_invalid_result_sign_injected(trigger_type, arg_list):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("invalid_result_sign"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("invalid_result_sign"):
                    return True
        return False

    def is_extra_op_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("extra_op"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_drop_result_statement_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("drop_result_stmt"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("drop_result_stmt"):
                    return True
        return False

    def is_sleep_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("sleep"):
                    func = generic_operation_parser(client_direct_msg_trigger[arg_list[1]])
                    interval = func["args"][0]
                    logging.info("HEAD sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("HEAD sleep completed.", extra=logger.NODE_INFO)
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(client_shuttle_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("HEAD sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("HEAD sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("drop()"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if arg_list[1] in client_direct_msg_trigger:
                if client_direct_msg_trigger[arg_list[1]].startswith("truncate_history"):
                    func = generic_operation_parser(client_direct_msg_trigger[arg_list[1]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("HEAD history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("HEAD new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True

            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(client_shuttle_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("HEAD history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("HEAD new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False

    def is_order_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("change_operation"):
                    return True
        return False

    def is_result_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("change_result"):
                    return True
        return False

    def is_slot_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("increment_slot"):
                    logging.info("HEAD will incremented slot. { Current_slot: %s }",
                                  str(current_slot), extra=logger.NODE_INFO)
                    return True
        return False

    def is_invalid_order_sign_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("invalid_order_sig"):
                    return True
        return False

    def is_invalid_result_sign_injected_forward_shuttle(trigger_type, arg_list):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("invalid_result_sign"):
                    return True
        return False

    def is_extra_op_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_drop_result_statement_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("drop_result_stmt"):
                    return True
        return False

    def is_sleep_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(client_shuttle_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "client_request" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_forward_shuttle(trigger_type, arg_list ):
        if "shuttle" in trigger_type:
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(client_shuttle_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False

    def is_order_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("change_operation"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("change_operation"):
                    return True
        return False

    def is_result_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("change_result"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("change_result"):
                    return True
        return False

    def is_invalid_order_sign_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("invalid_order_sig"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("invalid_order_sig"):
                    return True
        return False

    def is_invalid_result_sign_injected_fs_tail(trigger_type, arg_list):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("invalid_result_sign"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("invalid_result_sign"):
                    return True
        return False

    def is_extra_op_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("extra_op"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_drop_result_statement_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("drop_result_stmt"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("drop_result_stmt"):
                    return True
        return False

    def is_sleep_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("sleep"):
                    func = generic_operation_parser(client_result_shuttle_trigger[arg_list[1]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(client_shuttle_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("drop()"):
                    return True
            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_fs_tail(trigger_type, arg_list ):
        if "shuttle" in trigger_type or "result_shuttle" in trigger_type:
            if arg_list[1] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[1]].startswith("truncate_history"):
                    func = generic_operation_parser(client_result_shuttle_trigger[arg_list[1]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True

            if  arg_list[0] in client_shuttle_trigger:
                if client_shuttle_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(client_shuttle_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False 

    def is_result_injected_rs_tail(trigger_type, arg_list ):
        if  "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("change_result"):
                    return True
        return False

    def is_invalid_order_sign_injected_rs_tail(trigger_type, arg_list ):
        if "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("invalid_order_sig"):
                    return True
        return False

    def is_invalid_result_sign_injected_rs_tail(trigger_type, arg_list):
        if "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("invalid_result_sign"):
                    return True
        return False

    def is_extra_op_injected_rs_tail(trigger_type, arg_list ):
        if "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_drop_result_statement_injected_rs_tail(trigger_type, arg_list ):
        if "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("drop_result_stmt"):
                    return True
        return False

    def is_sleep_injected_rs_tail(trigger_type, arg_list ):
        if "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(client_result_shuttle_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_rs_tail(trigger_type, arg_list ):
        if "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_rs_tail(trigger_type, arg_list ):
        if "result_shuttle" in trigger_type:
            if arg_list[0] in client_result_shuttle_trigger:
                if client_result_shuttle_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(client_result_shuttle_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False

    def is_extra_op_injected_wedge(trigger_type, arg_list ):
        if "wedge_request" in trigger_type:
            if arg_list[0] in wedge_request_trigger:
                if wedge_request_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_sleep_injected_wedge(trigger_type, arg_list ):
        if "wedge_request" in trigger_type:
            if arg_list[0] in wedge_request_trigger:
                if wedge_request_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(wedge_request_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_wedge(trigger_type, arg_list ):
        if "wedge_request" in trigger_type:
            if arg_list[0] in wedge_request_trigger:
                if wedge_request_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_wedge(trigger_type, arg_list ):
        if "wedge_request" in trigger_type:
            if arg_list[0] in wedge_request_trigger:
                if wedge_request_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(wedge_request_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False

    def is_extra_op_injected_catch_up(trigger_type, arg_list ):
        if "caught_up" in trigger_type:
            if arg_list[0] in catch_up_trigger:
                if catch_up_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_sleep_injected_catch_up(trigger_type, arg_list ):
        if "caught_up" in trigger_type:
            if arg_list[0] in catch_up_trigger:
                if catch_up_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(catch_up_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_catch_up(trigger_type, arg_list ):
        if "caught_up" in trigger_type:
            if arg_list[0] in catch_up_trigger:
                if catch_up_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_catch_up(trigger_type, arg_list ):
        if "caught_up" in trigger_type:
            if arg_list[0] in catch_up_trigger:
                if catch_up_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(catch_up_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False

    def is_extra_op_injected_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_sleep_injected_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(checkpoint_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(checkpoint_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False

    def is_extra_op_injected_new_configuration():
        if configuration_num in new_configuration_trigger:
            if new_configuration_trigger[configuration_num].startswith("extra_op"):
                return True
        return False

    def is_sleep_injected_new_configuration():
        if configuration_num in new_configuration_trigger:
            if new_configuration_trigger[configuration_num].startswith("sleep"):
                func = generic_operation_parser(new_configuration_trigger[configuration_num])
                interval = func["args"][0]
                logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                time.sleep(int(interval))
                logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                return True
        return False

    def is_drop_injected_new_configuration():
        if configuration_num in new_configuration_trigger:
            if new_configuration_trigger[configuration_num].startswith("drop()"):
                return True
        return False

    def is_history_truncated_injected_new_configuration():
        if configuration_num in new_configuration_trigger:
            if new_configuration_trigger[configuration_num].startswith("truncate_history"):
                func = generic_operation_parser(new_configuration_trigger[configuration_num])
                count = func["args"][0]
                length = len(history)
                logging.info("Replica history will be truncated by %s entries." +
                     "{ CurrentLength: %s TruncateCount: %s }", str(count),
                     len(history), str(count), extra=logger.NODE_INFO)
                if length > int(count) :
                    history = history[:length-int(count)]
                else:
                    history = []
                logging.info("Replica new history. { New Length: %s  }",
                             len(history), extra=logger.NODE_INFO)
                return True
        return False

    def is_drop_checkpt_stmts_injected_completed_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type or "completed_checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("drop_checkpt_stmnts"):
                    return True
            if arg_list[1] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[1]].startswith("drop_checkpt_stmnts"):
                    return True
        return False


    def is_extra_op_injected_completed_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type or "completed_checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("extra_op"):
                    return True
            if arg_list[1] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[1]].startswith("extra_op"):
                    return True
        return False

    def is_sleep_injected_completed_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type or "completed_checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(checkpoint_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
            if arg_list[1] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[1]].startswith("sleep"):
                    func = generic_operation_parser(completed_checkpoint_trigger[arg_list[1]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_completed_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type or "completed_checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("drop()"):
                    return True
            if arg_list[1] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[1]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_completed_checkpoint(trigger_type, arg_list ):
        if "checkpoint" in trigger_type or "completed_checkpoint" in trigger_type:
            if arg_list[0] in checkpoint_trigger:
                if checkpoint_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(checkpoint_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True

            if arg_list[1] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[1]].startswith("truncate_history"):
                    func = generic_operation_parser(completed_checkpoint_trigger[arg_list[1]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False


    def is_drop_checkpt_stmts_injected_rslt_completed_checkpoint(trigger_type, arg_list ):
        if "completed_checkpoint" in trigger_type:
            if arg_list[0] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[0]].startswith("drop_checkpt_stmnts"):
                    return True
        return False


    def is_extra_op_injected_rslt_completed_checkpoint(trigger_type, arg_list ):
        if "completed_checkpoint" in trigger_type:
            if arg_list[0] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[0]].startswith("extra_op"):
                    return True
        return False

    def is_sleep_injected_rslt_completed_checkpoint(trigger_type, arg_list ):
        if "completed_checkpoint" in trigger_type:
            if arg_list[0] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[0]].startswith("sleep"):
                    func = generic_operation_parser(completed_checkpoint_trigger[arg_list[0]])
                    interval = func["args"][0]
                    logging.info("Replica sleep will be triggered.", extra=logger.NODE_INFO)
                    time.sleep(int(interval))
                    logging.info("Replica sleep completed.", extra=logger.NODE_INFO)
                    return True
        return False

    def is_drop_injected_rslt_completed_checkpoint(trigger_type, arg_list ):
        if "completed_checkpoint" in trigger_type:
            if arg_list[0] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[0]].startswith("drop()"):
                    return True
        return False

    def is_history_truncated_injected_rslt_completed_checkpoint(trigger_type, arg_list ):
        if "completed_checkpoint" in trigger_type:
            if arg_list[0] in completed_checkpoint_trigger:
                if completed_checkpoint_trigger[arg_list[0]].startswith("truncate_history"):
                    func = generic_operation_parser(completed_checkpoint_trigger[arg_list[0]])
                    count = func["args"][0]
                    length = len(history)
                    logging.info("Replica history will be truncated by %s entries." +
                         "{ CurrentLength: %s TruncateCount: %s }", str(count),
                         len(history), str(count), extra=logger.NODE_INFO)
                    if length > int(count) :
                        history = history[:length-int(count)]
                    else:
                        history = []
                    logging.info("Replica new history. { New Length: %s  }",
                                 len(history), extra=logger.NODE_INFO)
                    return True
        return False 

    # Only head is supposed to handle order request from client
    def receive(msg=('request_order', client, client_no, unique_order_ide,
                     order_req,)):

        if self.prev == None:
            #send(('req_reconfiguration', replica_no), to=olympus)

            ## If state is not ACTIVE return
            if state == "IMMUTABLE":
                return

            client_last_op[client_no] = order_req

            logging.info("HEAD received ORDER_REQUEST from client. { OrderNo" +
                         ": %s, OrderRequest: %s, ClientNo: %s }",
                         unique_order_ide, str(order_req), str(client_no),
                         extra=logger.NODE_INFO)

            self.opr_count_chk_pt = self.opr_count_chk_pt + 1
            if self.opr_count_chk_pt % 3 == 0:
                self.checkpoint_counter = self.checkpoint_counter + 1
                #print("checkpointing counter - ", opr_count_chk_pt)
                start_check_pointing()
                #if checkpoint_ind == 2:
                #    send(('req_reconfiguration', replica_no), to=olympus)

            # Injected code ---- Start
            if client_no not in client_shuttle_counter:
                client_shuttle_counter[client_no] = 0
            client_shuttle_counter[client_no] += 1

            if client_no not in client_direct_msg_counter:
                client_direct_msg_counter[client_no] = 0
            client_direct_msg_counter[client_no] += 1

            trigger_types = ["shuttle", "client_request"]
            order_inj = order_req
            shuttle_key = str(client_no) + "_" + str(client_shuttle_counter[client_no])
            client_key  = str(client_no) + "_" + str(client_direct_msg_counter[client_no])

            if is_order_injected(trigger_types, [shuttle_key, client_key]):
                order_inj = "get('X')"

            # Injected code -----End

            handle_client_req_at_head(client, client_no, unique_order_ide,
                                      order_inj, trigger_types,
                                      [shuttle_key, client_key])
        else:

            logging.info("Only HEAD must take order request from client",
                         extra=logger.NODE_INFO)
        return

    # Forward Shuttle to next
    def receive(msg=('forward_shuttle', client, client_no, unique_order_ide,
                     order_proofs, result_proofs, ), from_=self.prev):
        logging.info("Received FORWARD_SHUTTLE from previous replica in " +
                     "chain. { OrderNo: %s, OrderRequest: %s ClientNo: %s " +
                     " PreviousReplicaName: %s", unique_order_ide,
                     order_proofs[0][1], str(client_no),
                     replicas_name[int(replica_no)-1], extra=logger.NODE_INFO)

        if self.next_r != None:
            non_head_time_out_counter[unique_order_ide] = current_milli_time()
            print("Non Head current time - ", non_head_time_out_counter[unique_order_ide])

            print("Received forward shuttle - ", unique_order_ide)


            # Injected code ---- Start
            if client_no not in client_shuttle_counter:
                client_shuttle_counter[client_no] = 0
            client_shuttle_counter[client_no] += 1
            shuttle_key = str(client_no) + "_" + str(client_shuttle_counter[client_no])
            triggers = ["shuttle"]
            keys = [shuttle_key]

            invalid_order_sign = False
            invalid_result_sign = None 
            injected_result = None
            injected_extra_op = None
            injected_drop_result_statement = None
            injected_drop = None

            if triggers != None:

                if is_invalid_order_sign_injected_forward_shuttle(triggers, keys):
                     invalid_order_sign = True

                if is_invalid_result_sign_injected_forward_shuttle(triggers, keys):
                    invalid_result_sign = True

                if is_result_injected_forward_shuttle(triggers, keys):
                    injected_result = "OK"

                if is_extra_op_injected_forward_shuttle(triggers, keys ):
                    injected_extra_op = "put('a','a')"

                if is_drop_result_statement_injected_forward_shuttle(triggers, keys):
                    injected_drop_result_statement = True

                if is_sleep_injected_forward_shuttle(triggers, keys):
                    print("Sleep injected")

                if is_drop_injected_forward_shuttle(triggers, keys ):
                    injected_drop = True

                if is_history_truncated_injected_forward_shuttle(triggers, keys ):
                    print("Truncated History")

            if injected_extra_op != None:
                extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

            # Injected code ----------- End

            if is_valid_order_proofs(order_proofs):
                rcv_current_slot, order_req = get_slot_order(order_proofs)

                '''if rcv_current_slot - current_slot > 1:
                    print("Slot se cher char hua hai !!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    send(('req_reconfiguration', replica_no), to=olympus)'''

                client_last_op[client_no] = order_req

                order_inj = order_req
                if is_order_injected_forward_shuttle(triggers, keys):
                    order_inj = "get('X')"

                predecessor_order_proof = order_proofs[replica_no - 1][3]
                order_proofs.append(combine_order_proof(rcv_current_slot,
                                    order_inj, predecessor_order_proof, invalid_order_sign))
                result = command_executor.get_result(order_inj, running_state)

                if injected_result != None:
                    result = injected_result

                history.append(order_proofs)
                cache[unique_order_ide] = [result]
                predecessor_results = []
                if len(result_proofs) == replica_no:
                    predecessor_results = result_proofs[replica_no - 1][3]
                result_proofs.append(combine_result_proof(result, order_inj,
                                     predecessor_results, invalid_result_sign))

                if injected_drop_result_statement != None:
                    result_proofs = result_proofs[1:]

                logging.info("Sending FORWARD_SHUTTLE to next replica in " +
                             "chain. {OrderNo: %s, OrderRequest: %s ClientNo" +
                             ":%s NextReplicaName: %s }", unique_order_ide,
                             order_proofs[0][1], str(client_no),
                             replicas_name[int(replica_no)+1],
                             extra=logger.NODE_INFO)
                print ("Forwarding shuttle - ", unique_order_ide)
                if injected_drop == None:
                    send(('forward_shuttle', client, client_no, unique_order_ide,
                         order_proofs, result_proofs,), to=self.next_r)
            # else make reconfiguration call to olympus
        else:

            if client_no not in client_shuttle_counter:
                client_shuttle_counter[client_no] = 0
            client_shuttle_counter[client_no] += 1

            if client_no not in client_result_shuttle_counter:
                    client_result_shuttle_counter[client_no] = 0
            client_result_shuttle_counter[client_no] += 1
            
            shuttle_key = str(client_no) + "_" + str(client_shuttle_counter[client_no])
            result_key = str(client_no) + "_" + str(client_result_shuttle_counter[client_no])

            triggers = ["shuttle", "result_shuttle"]
            keys = [shuttle_key, result_key]

            print("Received forward shuttle - ", unique_order_ide)

            # Injection Code Start
            invalid_order_sign = False
            invalid_result_sign = None 
            injected_result = None
            injected_extra_op = None
            injected_drop_result_statement = None
            injected_drop = None

            if triggers != None:

                if is_invalid_order_sign_injected_fs_tail(triggers, keys):
                     invalid_order_sign = True

                if is_invalid_result_sign_injected_fs_tail(triggers, keys):
                    invalid_result_sign = True

                if is_result_injected_fs_tail(triggers, keys):
                    injected_result = "OK"

                if is_extra_op_injected_fs_tail(triggers, keys ):
                    injected_extra_op = "put('a','a')"

                if is_drop_result_statement_injected_fs_tail(triggers, keys):
                    injected_drop_result_statement = True

                if is_sleep_injected_fs_tail(triggers, keys):
                    print("Sleep injected")

                if is_drop_injected_fs_tail(triggers, keys ):
                    injected_drop = True

                if is_history_truncated_injected_fs_tail(triggers, keys ):
                    print("Truncated History")

            if injected_extra_op != None:
                extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

            # Injected code ----------- End
            

            if is_valid_order_proofs(order_proofs):
                current_slot, order_req = get_slot_order(order_proofs)

                client_last_op[client_no] = order_req

                # Injected code ------ Start
                order_inj = order_req
                if is_order_injected_fs_tail(triggers, keys):
                     order_inj = "get('X')"

                result = command_executor.get_result(order_inj, running_state)
                if injected_result != None:
                     result = injected_result

                # Injected code ------ End
                predecessor_results = []
                if len(result_proofs) == replica_no:
                    predecessor_results = result_proofs[replica_no - 1][3]
                result_proofs.append(combine_result_proof(result, order_inj,
                                     predecessor_results, invalid_result_sign))
                cache[unique_order_ide] = [result, result_proofs]

                # Injection code ----- Start
                if injected_drop_result_statement != None:
                    result_proofs = result_proofs[1:]
                # Injected code ------ End

                logging.info("Sending RESULT_PROOF to Client. { OrderNo:" +
                             " %s, OrderRequest: %s Result: %s ClientNo:" +
                             " %s }", unique_order_ide, order_proofs[0][1],
                             result, str(client_no),
                             extra=logger.NODE_INFO)

                print ("sending result proof to client - ", unique_order_ide)
                if injected_drop == None:
                    send(('result_proof', result_proofs,
                          self.replica_no, unique_order_ide), to=client)

                predecessor_order_proof = order_proofs[replica_no - 1][3]
                order_proofs.append(combine_order_proof(current_slot,
                                    order_inj, predecessor_order_proof, invalid_order_sign))
                history.append(order_proofs)

                logging.info("Sending REVERSE_SHUTTLE to previous " +
                             "replica in chain. { OrderNo: %s, " +
                             "OrderRequest: %s Result: %s ClientNo: " +
                             "%s PreviousReplicaName: %s }",
                             unique_order_ide, order_proofs[0][1], result,
                             str(client_no),
                                replicas_name[int(replica_no)-1],
                             extra=logger.NODE_INFO)
                print ("sending back result proof - ", unique_order_ide)
                print("checkpont Completed ***********************")
                print(checkpoint_ind, " -  ", client_last_op)
                print(checkpoint)
                print("History : ")
                for his in history:
                    for order_proofs in his:
                        print("slot - ", order_proofs[0], " order - ", order_proofs[1], \
                            " replica - ", order_proofs[2], "  sign - ", len(order_proofs[3]))
                print("checkpont return Success ***********************")
                if injected_drop == None:
                    send(('result_shuttle', unique_order_ide, client_no,
                          result_proofs,), to=self.prev)
            else:
                print ("order proof verification failed  - ", unique_order_ide)
            return
                #else:  No verification for result proof at tail
                #    print("Result proof error so raise reconfiguration")

    # Return Shuttle from next
    def receive(msg=('result_shuttle', unique_order_ide, client_no,
                     result_proof_pair,), from_=self.next_r):

        if self.next_r != None:
            logging.info("Received REVERSE_SHUTTLE from next replica in " +
                         "chain. { OrderNo: %s, ClientNo: %s Result: %s}",
                         str(unique_order_ide), str(client_no),
                         result_proof_pair[0][0], extra=logger.NODE_INFO)

        if client_no not in client_result_shuttle_counter:
            client_result_shuttle_counter[client_no] = 0
        client_result_shuttle_counter[client_no] += 1
        
        result_key = str(client_no) + "_" + str(client_result_shuttle_counter[client_no])

        triggers = ["result_shuttle"]
        keys = [result_key]

        print("Received forward shuttle - ", unique_order_ide)
        
        # Injection Code Start
        invalid_order_sign = False
        invalid_result_sign = None 
        injected_result = None
        injected_extra_op = None
        injected_drop_result_statement = None
        injected_drop = None

        if triggers != None:

            if is_invalid_order_sign_injected_rs_tail(triggers, keys):
                 invalid_order_sign = True

            if is_invalid_result_sign_injected_rs_tail(triggers, keys):
                invalid_result_sign = True

            if is_result_injected_rs_tail(triggers, keys):
                injected_result = "OK"

            if is_extra_op_injected_rs_tail(triggers, keys ):
                injected_extra_op = "put('a','a')"

            if is_drop_result_statement_injected_rs_tail(triggers, keys):
                injected_drop_result_statement = True

            if is_sleep_injected_rs_tail(triggers, keys):
                print("Sleep injected")

            if is_drop_injected_rs_tail(triggers, keys ):
                injected_drop = True

            if is_history_truncated_injected_rs_tail(triggers, keys ):
                print("Truncated History")

        if injected_extra_op != None:
            extra_op_ret = command_executor.get_result(injected_extra_op, running_state)

        # Injected code ----------- End
            
        print("Received result shuttle from next for - ", unique_order_ide)
        try:
            result_with_proof = cache[unique_order_ide]
            msg = 16 * str.encode(result_with_proof[0])
            digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)

            result_with_proof.append(result_proof_pair)
            cache[unique_order_ide] = result_with_proof

            # Injected code ----------- Start
            if injected_result != None:
                result_proofs = result_proof_pair[1]
                result_proof_pair = ("OK", result_proofs)
            
            if injected_drop_result_statement != None: 
                result_proofs = result_proof_pair[1][1:]
                result_proof_pair = (result_proof_pair[0], result_proofs)

            if invalid_result_sign != None:
                fake_key = nacl.signing.SigningKey.generate()
                signed = fake_key.sign(digest)
                result_proof_pair = result_proof_pair[:int(replica_no)] + result_proof_pair[int(replica_no)+1:]
                result_proof_pair = result_proof_pair[:int(replica_no)] + [signed] + result_proof_pair[int(replica_no):]

            # Injected code ------ End
            if self.prev != None:
                time_taken = int(current_milli_time()) - int(non_head_time_out_counter[unique_order_ide])
                print("Time taken by shuttle ", unique_order_ide, " - ", str(time_taken))
                if time_taken > int(non_head_time_out):
                    print("Reconfiguration because of non_head timeout")


                logging.info("Sending REVERSE_SHUTTLE to previous replica in " +
                             "chain. { OrderNo: %s, ClientNo: %s Result: %s }",
                             str(unique_order_ide), str(client_no),
                             result_proof_pair[0][0], extra=logger.NODE_INFO)
                if is_valid_result_proof(result_proof_pair, result_with_proof[0]):
                    if injected_drop == None:
                         send(('result_shuttle', unique_order_ide, client_no,
                              result_proof_pair,), to=self.prev)
                else:
                    print("Raise reconfiguration as result proof has exception")
                    logging.info("Riase reconfiguration request due to result proof MISBEHAVIOUR", 
                                 extra=logger.NODE_INFO)
            else:
                time_taken = int(current_milli_time()) - int(head_time_out_counter[unique_order_ide])
                print("Time taken by shuttle ", unique_order_ide, " - ", str(time_taken))
                if time_taken > int(head_time_out):
                    print("Reconfiguration because of head timeout")

            print("checkpont Completed ***********************")
            print(checkpoint_ind, " - ", client_last_op)
            print(checkpoint)
            print("History : ")
            for his in history:
                for order_proofs in his:
                    print("slot - ", order_proofs[0], " order - ", order_proofs[1],\
                         " replica - ", order_proofs[2], "  sign - ", len(order_proofs[3]))
            print(" checkpont return Success ***********************")
        except KeyError:
            print("Due to new configuration, client is required to resend this order")
        return

    # Re-transmission from client
    def receive(msg=('retransmission', client, client_no, order_id, order,)):

        logging.info("Received retransmission request from Client. {OrderNo:" +
                     "%s, Order: %s, ClientNo: %s, ClientId: %s}",
                     str(order_id), str(order), str(client_no), str(client),
                     extra=logger.NODE_INFO)

        if state == 'IMMUTABLE':
            return

        client_last_op[client_no] = order

        if client_no not in client_direct_msg_counter:
            client_direct_msg_counter[client_no] = 0
        client_direct_msg_counter[client_no] += 1
        print("Retrnsmission request received - ", order_id)
        set_global_operation(order)
        trigger_failure_injection_for_shuttle(client_no,
                                              client_direct_msg_counter
                                              [client_no])
        order_req = get_injected_operation(client_no,
                                           client_direct_msg_counter
                                           [client_no])
        if order_id in cache and len(cache[order_id]) == 2:
            logging.info("Found result in cache. { OrderNo: %s}", order_id,
                         extra=logger.NODE_INFO)

            result = cache[order_id][0]
            result_proofs = cache[order_id][1]
            injected_result = get_injected_result(client_no,
                                                  client_direct_msg_counter
                                                  [client_no])
            if injected_result != None:
                result = "OK"
            if get_injected_drop_stmt(client_no,
                                      client_direct_msg_counter[client_no]):
                result_proofs = result_proofs[1][1:]
            result_proof_pair = (result, result_proofs)

            logging.info("Retransmission result send to client from cached" +
                         "result. {RESULT: %s , FromReplica: %s ToClient: %s}",
                         result_proof_pair[0], str(replica_no), str(client_no),
                         extra=logger.NODE_INFO)
            
            if order_req == cache[order_id]:
                print("sending retransmission respose from cache for - ", order_id)

                send(('retransmission_result', result_proof_pair, replica_no, order_id,),
                 to=client)
            else:
                print("***************************************************")
                print("This order was changed, hence reconfiguration")
                send(('req_reconfiguration', replica_no), to=olympus)
        else:
            logging.info("Retransmission request send to HEAD. {OrderNo: %s" +
                         "OrderRequest: %s ClientNo: %s ClientId: %s}",
                         str(order_id), str(order_req), str(client_no),
                         str(client), extra=logger.NODE_INFO)

            print("since trans rqst not in cache, forwarding to head")
            send(('retransmission_to_head', client, client_no,  self,
                 order_id, order_req,), to=replicas[0])
            if await(received(('retransmission_ack', order_id))):
                print("Ack from head received, do nothing")
                logging.info("Retransmission ACK received from HEAD for " +
                             "OrderNo {%s}. Do nothing !!!", order_id,
                             extra=logger.NODE_INFO)

            elif timeout(int(time_out) / 1000):
                print("Reconfiguration request raised by ", self)
                logging.info("Reconfiguration request raised by self",
                             extra=logger.NODE_INFO)

    def run():
        print("Replica : ", str(self.me))
        logging.info("Running Replica...", extra=logger.NODE_INFO)
        set_failure_triggers()
        while True:
            await(received(('',)))
