from src.utils import logger 
import sys
import os
import logging
import time
import re
from src.utils import config_parser
from src.utils import command_executor
import nacl.encoding
import nacl.signing
import nacl.hash


REPLICA_HOSTS = "replica_hosts"
FAILURES_TO_TOLERATE = "t"
HEAD_TIMEOUT = "head_timeout"
NON_HEAD_TIMEOUT = "nonhead_timeout"
HASHER = nacl.hash.sha256

class replica(process):    

    def setup(config_file, replica_no, replicas, replicas_name, olympus, \
        oly_verify_key, replica_verify_keys, sign_key):
        ## cache for storing result and result proof

        self.cache = {}

        ## current_slot updated only by head replica

        self.current_slot = 0

        ## running state of replica

        self.running_state = {}

        ## history of replica

        self.history = []

        ## Update next and previous replica by each replica

        self.num_of_replicas = len(replicas)
        if replica_no == 0:
            self.prev = None
            self.me = replicas[0]
            self.next_r = replicas[1]
            
            # Setting log file for head Node

            logger.setLogFormatting(replicas_name[replica_no] + '.log', logger.getLogDir(),
                                    logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values

            logging.info("HEAD received setup - config_file: %s replica_list: " +
                         "%s replica_name: %s olympus: {Id: %s}",
                         config_file, replicas[replica_no], replicas_name[replica_no], olympus,
                         extra=logger.NODE_INFO)

        elif replica_no == len(replicas) - 1:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = None
 
            # Setting log file for tail Node

            logger.setLogFormatting(replicas_name[replica_no] + '.log', logger.getLogDir(),
                                    logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values

            logging.info("TAIL received setup - config_file: %s replica_list: " +
                         "%s replica_name: %s olympus: {Id: %s}",
                         config_file, replicas[replica_no], replicas_name[replica_no], olympus,
                         extra=logger.NODE_INFO)

        else:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = replicas[replica_no + 1]
 
            # Setting log file for other replica Node

            logger.setLogFormatting(replicas_name[replica_no] + '.log', logger.getLogDir(),
                                    logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values

            logging.info("Replica received setup - config_file: %s replica_list: " +
                         "%s replica_name: %s olympus: {Id: %s}",
                         config_file, replicas[replica_no], replicas_name[replica_no], olympus,
                         extra=logger.NODE_INFO)

       
        ## Setting timeout for replica head and non-head
        config = config_parser.get_config(config_file)
        self.head_time_out = config[HEAD_TIMEOUT]
        self.non_head_time_out = config[NON_HEAD_TIMEOUT]
 
        if prev == None:
            self.time_out = head_time_out
            logging.info("HEAD timeout - %s", str(head_time_out),
                         extra=logger.NODE_INFO)
        else:
            self.time_out = non_head_time_out
            logging.info("Replica timeout - %s", str(non_head_time_out),
                         extra=logger.NODE_INFO)
        return
    
    def combine_order_proof(slot_no, order_string, predecessor_orders):
        tup = (str(slot_no), order_string, str(replica_no))
        #tup_str = ''.join(tup)
        signed = sign_key.sign(str.encode(str(tup)))
        predecessor_orders.append(signed)
        return (slot_no, order_string, replica_no, predecessor_orders)

    def create_order_proof(slot_no, order_string):
        tup = (str(slot_no), order_string, str(replica_no))
        #tup_str = ''.join(tup)
        signed = sign_key.sign(str.encode(str(tup)))
        predecessor_order_proofs = [signed]
        return (slot_no, order_string, replica_no, predecessor_order_proofs)

    def get_result_proof(result):
        msg = 16 * str.encode(result)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        return sign_key.sign(digest)
        
    def is_valid_order_proofs(order_proofs):
        if len(order_proofs) < 1:
            return False
        for ind in range(0, replica_no):
            for sec in range(0, ind + 1):
                order_proof = order_proofs[ind]
                verify_key = replica_verify_keys[sec]
                try:
                    verify_key.verify(order_proof[3][sec])
                except nacl.exceptions.BadSignatureError:
                    return False 
        return True

    def get_slot_order(order_proof):
        first_order_st = order_proof[0]
        return first_order_st[0], first_order_st[1]
    
    # Retransmission ack from head to replica
    def receive(msg=('retransmission_ack', order_id), from_ =replicas[0]):
        if prev != None:
            print('Received ack from head for retransmission, cancelling timeout')
            logging.info("Received ack from head for retransmission, cancelling" +
                         "timeout", extra=logger.NODE_INFO)

    # Eventually head will deal with re-transmission from replicas
    def receive(msg=('retransmission_to_head', client, replica, order_id, order,)):

        if self.prev == None:
            print('Retransmission request forwarded from replica ......')
            logging.info("Retransmission request forwarded from replica" +
                         "......", extra=logger.NODE_INFO)

            if order_id in cache and len(cache[order_id]) == 2:
                send(('retransmission_result', cache[order_id], replica_no,), to = client)

                logging.info("Sending retransmission_ack ACK: {orderId: %s}",
                             str(order_id), extra=logger.NODE_INFO)

                send(('retransmission_ack', order_id), to = replica)

            elif order_id in cache and len(cache[order_id]) == 1:
                if await(len(cache[order_id]) == 2):
                    send(('retransmission_result', cache[order_id], replica_no,), to = client)
                    send(('retransmission_ack', order_id), to = replica)

                elif timeout(int(time_out) / 1000):
                    handle_client_req_at_head(client, order_id, order)
                    if await(len(cache[order_id]) == 2):
                        send(('retransmission_result', cache[order_id], replica_no,), to = client)
                        send(('retransmission_ack', order_id), to = replica)

                    elif timeout(int(time_out) / 1000):
                        print("Request of reconfiguration from head")
                        logging.info("Request of reconfiguration from head",
                                     extra=logger.NODE_INFO)
        else:
            print('I am not the head to eventually deal with re transmission request')

    def handle_client_req_at_head(client, unique_order_ide, order_req):
        print("Forwarding order request to next : ", order_req)
        current_slot += 1
        ## No need to verify order proof at head
        order_proofs = []
        ## order proof is a list of tuples (slot, order, replica, [digtal signs of preceding])
        order_proofs.append(create_order_proof(current_slot, order_req))
        result = command_executor.get_result(order_req, running_state)
        if result != None:
            cache[unique_order_ide] = [result]
            result_proof = []
            result_proof.append(get_result_proof(result))
            send(('forward_shuttle', client, unique_order_ide, \
                order_proofs, result_proof,), to = next_r)    

    # Only head is supposed to handle order request from client    
    def receive(msg=('request_order', client, unique_order_ide, order_req,)):
        print("Received order request from " + str(client))
        if self.prev == None:
            handle_client_req_at_head(client, unique_order_ide, order_req)
        else:
            print("I am not the head to take order request from client")

    # Forward Shuttle to next
    def receive(msg=('forward_shuttle', client, unique_order_ide, \
         order_proofs, result_proofs, ), from_ = self.prev):
        if self.next_r != None:
            print("Forwarding order request to next : ", order_proofs)
            if is_valid_order_proofs(order_proofs):
                current_slot, order_req = get_slot_order(order_proofs)
                predecessor_order_proof = order_proofs[replica_no - 1][3]
                order_proofs.append(combine_order_proof(current_slot, order_req, predecessor_order_proof))
                result = command_executor.get_result(order_req, running_state)
                cache[unique_order_ide] = [result]
                result_proofs.append(get_result_proof(result)) 
                send(('forward_shuttle', client, unique_order_ide, \
                     order_proofs, result_proofs,), to = self.next_r)
            ## else make reconfiguration call to olympus
        else:
            print("I am the tail and sending to client")
            if is_valid_order_proofs(order_proofs):
                current_slot, order_req = get_slot_order(order_proofs)
                order_proofs.append(create_order_proof(current_slot, order_req))
                result = command_executor.get_result(order_req, running_state)
                result_proofs.append(get_result_proof(result))
                cache[unique_order_ide] = [result, result_proofs]
                send(('result_proof', (result, result_proofs), self.replica_no, unique_order_ide), to = client)
                history.append(order_proofs)
                print("sending result proof shuttle back")
                send(('result_shuttle', unique_order_ide, result_proofs,), to = self.prev)
    
    # Return Shuttle from next
    def receive(msg=('result_shuttle', unique_order_ide, result_proof,), from_ = self.next_r):
        output("Received  result from next")
        result_with_proof = cache[unique_order_ide]
        result_with_proof.append(result_proof)
        cache[unique_order_ide] = result_with_proof
        if self.prev != None:
            print("Forwarding result proof to prev : ")
            send(('result_shuttle', unique_order_ide, result_proof,), to = self.prev)
        else:
            print("I am the Head and have received result proof shuttle")
            print(result_proof)

    # Re-transmission from client
    def receive(msg=('retransmission', client, order_id, order,)):
        print('Retrnsmission request received...... sending response')
        print("cache ", cache)
        if order_id in cache and len(cache[order_id]) == 2:
            print('I have cashed value for order_id ', order_id, " ")
            send(('retransmission_result', cache[order_id], replica_no,), to = client)
        else:
            send(('retransmission_to_head', client, self, \
                order_id, order,), to = replicas[0])
            if await(received(('retransmission_ack', "=order_id",))):
                print("Ack from head received, do nothing")
            elif timeout(int(time_out) / 1000):
                print("Reconfiguration request raised by ", self)

    def run():
        print("Replica : ", str(self.me))
        while True:
            await(received(('',)))

