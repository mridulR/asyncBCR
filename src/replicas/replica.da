from src.utils import logger 
import sys
import os
import logging
import time
import re
from src.utils import config_parser
from src.utils import command_executor
import nacl.encoding
import nacl.signing
import nacl.hash


REPLICA_HOSTS = "replica_hosts"
FAILURES_TO_TOLERATE = "t"
HEAD_TIMEOUT = "head_timeout"
NON_HEAD_TIMEOUT = "nonhead_timeout"
HASHER = nacl.hash.sha256

class replica(process):


    def setup(config_file, replica_no, replicas, replicas_name, olympus, \
        oly_verify_key, replica_verify_keys, sign_key):
        ## cache for storing result and result proof

        self.cache = {}
        
        self.client_direct_msg_trigger = {}
        self.client_fwd_rqst_trigger = {}
        self.client_shuttle_trigger = {}
        self.client_result_shuttle_trigger = {}

        self.client_direct_msg_counter = {}
        self.client_fwd_rqst_counter = {}
        self.client_shuttle_counter = {}
        self.client_result_shuttle_counter = {}

        ## current_slot updated only by head replica

        self.current_slot = 0

        ## running state of replica

        self.running_state = {}

        ## history of replica

        self.history = []


        ## Update next and previous replica by each replica

        self.num_of_replicas = len(replicas)
        if replica_no == 0:
            self.prev = None
            self.me = replicas[0]
            self.next_r = replicas[1]
            
            # Setting log file for head Node

            logger.setLogFormatting(replicas_name[replica_no] + '.log', logger.getLogDir(),
                                    logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values

            logging.info("HEAD received setup - config_file: %s replica_list: " +
                         "%s replica_name: %s olympus: {Id: %s}",
                         config_file, replicas[replica_no], replicas_name[replica_no], olympus,
                         extra=logger.NODE_INFO)

        elif replica_no == len(replicas) - 1:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = None
 
            # Setting log file for tail Node

            logger.setLogFormatting(replicas_name[replica_no] + '.log', logger.getLogDir(),
                                    logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values

            logging.info("TAIL received setup - config_file: %s replica_list: " +
                         "%s replica_name: %s olympus: {Id: %s}",
                         config_file, replicas[replica_no], replicas_name[replica_no], olympus,
                         extra=logger.NODE_INFO)

        else:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = replicas[replica_no + 1]
 
            # Setting log file for other replica Node

            logger.setLogFormatting(replicas_name[replica_no] + '.log', logger.getLogDir(),
                                    logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values

            logging.info("Replica received setup - config_file: %s replica_list: " +
                         "%s replica_name: %s olympus: {Id: %s}",
                         config_file, replicas[replica_no], replicas_name[replica_no], olympus,
                         extra=logger.NODE_INFO)

       
        ## Setting timeout for replica head and non-head
        self.config = config_parser.get_config(config_file)
        self.head_time_out = config[HEAD_TIMEOUT]
        self.non_head_time_out = config[NON_HEAD_TIMEOUT]
 
        if prev == None:
            self.time_out = head_time_out
            logging.info("HEAD timeout - %s", str(head_time_out),
                         extra=logger.NODE_INFO)
        else:
            self.time_out = non_head_time_out
            logging.info("Replica timeout - %s", str(non_head_time_out),
                         extra=logger.NODE_INFO)
        return

    def set_failure_triggers():
        for key,value in config.items():
            trigger_failure_list = []
            if key.startswith('failures'):
                config_replica = re.search(r'\[(.*?),(.*?)\]', key)
                config = int(config_replica.group(1))
                replica = int(config_replica.group(2))
                ### In phase 1 only concerned with config 0
                if config == 0 and replica == replica_no:
                    trigger_failures = [each.strip() for each in value.split(';')]
                    for trigg_fail in trigger_failures:
                        if trigg_fail.startswith("client_request"):
                            cli_msg = re.search(r'client_request\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_direct_msg_trigger[key] = cli_msg.group(3).strip()
                        elif trigg_fail.startswith("forwarded_request"):
                            cli_msg = re.search(r'forwarded_request\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_fwd_rqst_trigger[key] = cli_msg.group(3).strip()
                        elif trigg_fail.startswith("shuttle"):
                            cli_msg = re.search(r'shuttle\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_shuttle_trigger[key] = cli_msg.group(3).strip()
                        elif trigg_fail.startswith("result_shuttle"):
                            cli_msg = re.search(r'result_shuttle\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_result_shuttle_trigger[key] = cli_msg.group(3).strip()
                                                    
    
    def combine_order_proof(slot_no, order_string, predecessor_orders):
        tup = (str(slot_no), order_string, str(replica_no))
        #tup_str = ''.join(tup)
        signed = sign_key.sign(str.encode(str(tup)))
        predecessor_orders.append(signed)
        return (slot_no, order_string, replica_no, predecessor_orders)

    def create_order_proof(slot_no, order_string):
        tup = (str(slot_no), order_string, str(replica_no))
        #tup_str = ''.join(tup)
        signed = sign_key.sign(str.encode(str(tup)))
        predecessor_order_proofs = [signed]
        return (slot_no, order_string, replica_no, predecessor_order_proofs)

    def get_result_proof(result):
        msg = 16 * str.encode(result)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        return sign_key.sign(digest)
        
    def is_valid_order_proofs(order_proofs):
        if len(order_proofs) < 1:
            return False
        slot = order_proofs[0][0]
        order = order_proofs[0][1]
        if slot in cache:
            return False
        for ind in range(0, replica_no):
            order_proof = order_proofs[ind]
            pred_slot = order_proof[0]
            pred_order = order_proof[1]
            if slot != pred_slot or order != pred_order:
                return False
            for sec in range(0, ind + 1):
                verify_key = replica_verify_keys[sec]
                try:
                    verify_key.verify(order_proof[3][sec])
                except nacl.exceptions.BadSignatureError:
                    return False 
        return True

    def get_slot_order(order_proof):
        first_order_st = order_proof[0]
        return first_order_st[0], first_order_st[1]
    
    # Retransmission ack from head to replica
    def receive(msg=('retransmission_ack', order_id), from_ =replicas[0]):
        if prev != None:
            print('Received ack from head for retransmission, cancelling timeout')
            logging.info("Received ack from head for retransmission, cancelling" +
                         "timeout", extra=logger.NODE_INFO)

    # Eventually head will deal with re-transmission from replicas
    def receive(msg=('retransmission_to_head', client, client_no, replica, order_id, order,)):

        if self.prev == None:
            if client_no not in client_fwd_rqst_counter:
                client_fwd_rqst_counter[client_no] = 0
            client_fwd_rqst_counter[client_no]
            print('Retransmission request forwarded from replica ......')
            logging.info("Retransmission request forwarded from replica" +
                         "......", extra=logger.NODE_INFO)

            if order_id in cache and len(cache[order_id]) == 2:
                send(('retransmission_result', cache[order_id], replica_no,), to = client)

                logging.info("Sending retransmission_ack ACK: {orderId: %s}",
                             str(order_id), extra=logger.NODE_INFO)

                send(('retransmission_ack', order_id), to = replica)

            elif order_id in cache and len(cache[order_id]) == 1:
                if await(len(cache[order_id]) == 2):
                    send(('retransmission_result', cache[order_id], replica_no,), to = client)
                    send(('retransmission_ack', order_id), to = replica)

                elif timeout(int(time_out) / 1000):
                    handle_client_req_at_head(client, client_no, order_id, order)
                    if await(len(cache[order_id]) == 2):
                        send(('retransmission_result', cache[order_id], replica_no,), to = client)
                        send(('retransmission_ack', order_id), to = replica)

                    elif timeout(int(time_out) / 1000):
                        print("Request of reconfiguration from head")
                        logging.info("Request of reconfiguration from head",
                                     extra=logger.NODE_INFO)
        else:
            print('I am not the head to eventually deal with re transmission request')

    def handle_client_req_at_head(client, client_no, unique_order_ide, order_req):
        print("Forwarding order request to next : ", order_req)
        current_slot += 1
        ## No need to verify order proof at head
        order_proofs = []
        ## order proof is a list of tuples (slot, order, replica, [digtal signs of preceding])
        order_proofs.append(create_order_proof(current_slot, order_req))
        result = command_executor.get_result(order_req, running_state)
        if result != None:
            cache[unique_order_ide] = [result]
            result_proof = []
            result_proof.append(get_result_proof(result))
            send(('forward_shuttle', client, client_no, unique_order_ide, \
                order_proofs, result_proof,), to = next_r)    

    # Only head is supposed to handle order request from client    
    def receive(msg=('request_order', client, client_no, unique_order_ide, order_req,)):
        if self.prev == None:
            if client_no not in client_shuttle_counter:
                client_shuttle_counter[client_no] = 0
            client_shuttle_counter[client_no] += 1
            handle_client_req_at_head(client, client_no, unique_order_ide, order_req)
        else:
            print("I am not the head to take order request from client")


    # Forward Shuttle to next
    def receive(msg=('forward_shuttle', client, client_no, unique_order_ide, \
         order_proofs, result_proofs, ), from_ = self.prev):
        if client_no not in client_fwd_rqst_counter:
            client_fwd_rqst_counter[client_no] = 0
        client_fwd_rqst_counter[client_no] += 1
        if self.next_r != None:
            if is_valid_order_proofs(order_proofs):
                current_slot, order_req = get_slot_order(order_proofs)
                predecessor_order_proof = order_proofs[replica_no - 1][3]
                order_proofs.append(combine_order_proof(current_slot, order_req, predecessor_order_proof))
                result = command_executor.get_result(order_req, running_state)
                cache[unique_order_ide] = [result]
                result_proofs.append(get_result_proof(result)) 
                send(('forward_shuttle', client, client_no, unique_order_ide, \
                     order_proofs, result_proofs,), to = self.next_r)
            ## else make reconfiguration call to olympus
        else:
            print("I am the tail and sending to client")
            if is_valid_order_proofs(order_proofs):
                current_slot, order_req = get_slot_order(order_proofs)
                order_proofs.append(create_order_proof(current_slot, order_req))
                result = command_executor.get_result(order_req, running_state)
                result_proofs.append(get_result_proof(result))
                cache[unique_order_ide] = [result, result_proofs]
                send(('result_proof', (result, result_proofs), self.replica_no, unique_order_ide), to = client)
                history.append(order_proofs)
                print("sending result proof shuttle back")
                send(('result_shuttle', unique_order_ide, client_no, result_proofs,), to = self.prev)

    
    # Return Shuttle from next
    def receive(msg=('result_shuttle', unique_order_ide, client_no, result_proof,), from_ = self.next_r):
        if client_no not in client_result_shuttle_counter:
            client_result_shuttle_counter[client_no] = 0
        client_result_shuttle_counter[client_no] += 1
        output("Received  result from next")
        result_with_proof = cache[unique_order_ide]
        result_with_proof.append(result_proof)
        cache[unique_order_ide] = result_with_proof
        if self.prev != None:
            print("Forwarding result proof to prev : ")
            send(('result_shuttle', unique_order_ide, client_no, result_proof,), to = self.prev)
        else:
            print("I am the Head and have received result proof shuttle")


    # Re-transmission from client
    def receive(msg=('retransmission', client, client_no, order_id, order,)):
        if client_no not in client_direct_msg_counter:
            client_direct_msg_counter[client_no] = 0
        client_direct_msg_counter[client_no] += 1
        print('Retrnsmission request received...... sending response')
        print("cache ", cache)
        if order_id in cache and len(cache[order_id]) == 2:
            print('I have cashed value for order_id ', order_id, " ")
            send(('retransmission_result', cache[order_id], replica_no,), to = client)
        else:
            send(('retransmission_to_head', client, client_no,  self, \
                order_id, order,), to = replicas[0])
            if await(received(('retransmission_ack', "=order_id",))):
                print("Ack from head received, do nothing")
            elif timeout(int(time_out) / 1000):
                print("Reconfiguration request raised by ", self)


    def run():
        print("Replica : ", str(self.me))
        set_failure_triggers()
        while True:
            await(received(('',)))

