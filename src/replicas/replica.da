#!/usr/bin/python3
# -*- coding: utf-8 -*-
import sys
import os
import logging
import time
import re
import json
import nacl.encoding
import nacl.signing
import nacl.hash
from src.utils import config_parser
from src.utils import command_executor
from src.utils import logger

REPLICA_HOSTS = "replica_hosts"
FAILURES_TO_TOLERATE = "t"
HEAD_TIMEOUT = "head_timeout"
NON_HEAD_TIMEOUT = "nonhead_timeout"
HASHER = nacl.hash.sha256


class replica(process):
    """ An implementation to handle all the replicas."""

    def setup(config_file, replica_no, replicas, replicas_name, olympus,
              oly_verify_key, replica_verify_keys, sign_key):
        """ Setting up the replica based on configuration."""

        # client last opearation mapping
        self.client_last_op = {}

        # state of replica - ACTIVE and IMMUTABLE
        self.state = "ACTIVE"

        # configuration of replica
        self.config = 0


        # cache for storing result and result proof
        self.cache = {}

        #check-pointing
        self.opr_count_chk_pt = 0
        self.checkpoint_ind = 0
        self.checkpoint = {}

        # Testing
        self.global_operation = ""
        self.injected_get_operation = {}
        self.injected_change_result = {}
        self.injected_drop_result = {}
        self.client_direct_msg_trigger = {}
        self.client_fwd_rqst_trigger = {}
        self.client_shuttle_trigger = {}
        self.client_result_shuttle_trigger = {}
        self.client_direct_msg_counter = {}
        self.client_fwd_rqst_counter = {}
        self.client_shuttle_counter = {}
        self.client_result_shuttle_counter = {}

        # current_slot updated only by head replica
        self.current_slot = 0

        # running state of replica
        self.running_state = {}

        # history of replica
        self.history = []

        # Update next and previous replica by each replica
        self.num_of_replicas = len(replicas)
        if replica_no == 0:
            self.prev = None
            self.me = replicas[0]
            self.next_r = replicas[1]

            # Setting log file for head Node
            logger.setLogFormatting(replicas_name[replica_no] + '.log',
                                    logger.getLogDir(), logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values
            logging.info("HEAD received setup: { Config_file: %s," +
                         "Replicas_list: %s Replicas_name: %s, Olympus: %s }",
                         config_file, replicas, replicas_name, olympus,
                         extra=logger.NODE_INFO)

        elif replica_no == len(replicas) - 1:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = None

            # Setting log file for tail Node
            logger.setLogFormatting(replicas_name[replica_no] + '.log',
                                    logger.getLogDir(), logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values
            logging.info("TAIL received setup: { Config_file: %s," +
                         "Replicas_list: %s Replicas_name: %s, Olympus: %s }",
                         config_file, replicas, replicas_name, olympus,
                         extra=logger.NODE_INFO)

        else:
            self.prev = replicas[replica_no - 1]
            self.me = replicas[replica_no]
            self.next_r = replicas[replica_no + 1]

            # Setting log file for other replica Node
            logger.setLogFormatting(replicas_name[replica_no] + '.log',
                                    logger.getLogDir(), logging.INFO)
            logger.setLogNodeInfo(self, replicas_name[replica_no])

            # Log the received values
            logging.info("Replica received setup: { Config_file: %s," +
                         "Replicas_list: %s Replicas_name: %s, Olympus: %s }",
                         config_file, replicas, replicas_name, olympus,
                         extra=logger.NODE_INFO)

        # Setting timeout for replica head and non-head
        self.config = config_parser.get_config(config_file)
        self.head_time_out = config[HEAD_TIMEOUT]
        self.non_head_time_out = config[NON_HEAD_TIMEOUT]

        if prev == None:
            self.time_out = head_time_out
            logging.info("HEAD timeout value: %s ms", str(head_time_out),
                         extra=logger.NODE_INFO)
        else:
            self.time_out = non_head_time_out
            logging.info("Replica timeout value: %s ms",
                         str(non_head_time_out), extra=logger.NODE_INFO)
        return

    def set_failure_triggers():
        """ Setting up the injection point for each replica after reading the
            configuration from the config file.based on configuration. """

        for key, value in config.items():
            trigger_failure_list = []
            if key.startswith('failures'):
                config_replica = re.search(r'\[(.*?),(.*?)\]', key)
                config = int(config_replica.group(1))
                replica = int(config_replica.group(2))

                # In phase 2 only concerned with config 0
                if config == 0 and replica == replica_no:
                    trigger_failures = [each.strip() for each in value.split(';')]
                    for trigg_fail in trigger_failures:
                        if trigg_fail.startswith("client_request"):
                            cli_msg = re.search(r'client_request\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_direct_msg_trigger[key] = cli_msg.group(3).strip()
                        elif trigg_fail.startswith("forwarded_request"):
                            cli_msg = re.search(r'forwarded_request\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_fwd_rqst_trigger[key] = cli_msg.group(3).strip()
                        elif trigg_fail.startswith("shuttle"):
                            cli_msg = re.search(r'shuttle\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_shuttle_trigger[key] = cli_msg.group(3).strip()
                        elif trigg_fail.startswith("result_shuttle"):
                            cli_msg = re.search(r'result_shuttle\((.*?),(.*?)\),(.*?)\(\)', trigg_fail)
                            key = cli_msg.group(1) + "_" + cli_msg.group(2)
                            client_result_shuttle_trigger[key] = cli_msg.group(3).strip()
    return

    def combine_result_proof(result, order, predecessor_results):
        """ Updates the result_proof with it's own sign key on top of the
            predecessor's (the one before in the chain) result_proof. It hashes
            the result before signing and then only sends the result_proof
            over a shuttle in forward/backward direction. """

        msg = 16 * str.encode(result)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        signed = sign_key.sign(digest)
        predecessor_results.append(signed)
        return (result, order, replica_no, predecessor_results)

    def combine_order_proof(slot_no, order_string, predecessor_orders):
        """ Updates the order_proof received from predesessor replica, with
            it's own sign key on top of it and then sends the order_proof. A
            predecessor is the replica that comes immediately before it, in the
            chain. """

        tup = (str(slot_no), order_string, str(replica_no))
        signed = sign_key.sign(str.encode(str(tup)))
        predecessor_orders.append(signed)
        return (slot_no, order_string, replica_no, predecessor_orders)

    def create_order_proof(slot_no, order_string):
        """ HEAD replica creates the order_proof which is forwarded alongwith
            shuttle to the next replica in chain. Other replica's append their
            order_proof to this and send along the chain. The tail replica
            sends the order_proof on shuttle along the chain in opposite
            direction. """

        tup = (str(slot_no), order_string, str(replica_no))
        signed = sign_key.sign(str.encode(str(tup)))
        predecessor_order_proofs = [signed]
        return (slot_no, order_string, replica_no, predecessor_order_proofs)

    def create_result_proof(result, order):
        """ HEAD replica creates the result_proof which is forwarded alongwith
            shuttle to the next replica in chain. Other replica's append their
            result_proof to this and send along the chain. The tail replica
            sends the result_proof on shuttle along the chain in opposite
            direction as well as to the client. """

        msg = 16 * str.encode(result)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        signed = sign_key.sign(digest)
        return (result, order, replica_no, [signed])

    def is_valid_result_proof(result_proofs, cal_result):
        """ Validates if the result_proof is correct or not.
               -If the result doesn't match the predecessor replica's result
                then returns false.
               -If the order is not present in the predecessor's order.
                then returns false.
               -If the sign verification of the result_proof with predecessor
                replica's verify key fails, then return false. is not present
                in the predecessor's order then returns false.
               -If the result proof size is zero then return false.
               -otherwise return TRUE. """

        if len(result_proofs) < 1:
            logging.error("MISBEHAVIOUR: Empty Result Proof ",
                          extra=logger.NODE_INFO)
            return False


        result = result_proofs[0][0]
        order = result_proofs[0][1]
        for ind in range(0, len(replicas)):
            try:
                result_proof = result_proofs[ind]
                pred_result = result_proof[0]
                pred_order = result_proof[1]
                if result != pred_result or order != pred_order:
                    logging.error("MISBEHAVIOUR: Conflicting result or OrderNo " +
                              "does not match. {Result: %s, OrderNo: %s}" +
                              "{Predecessor Replica Result: %s ," +
                              "Predecessor Replica OrderNo: %s}", result,
                              order, pred_result, pred_order,
                              extra=logger.NODE_INFO)
                    return False
                for sec in range(0, ind + 1):
                    verify_key = replica_verify_keys[sec]
                    try:
                        verify_key.verify(result_proof[3][sec])
                    except nacl.exceptions.BadSignatureError:
                        logging.error("MISBEHAVIOUR: Bad signature error in " +
                                  "Result Proof", extra=logger.NODE_INFO)
                        return False
            except IndexError:
                return False
        return True

    def is_valid_order_proofs(order_proofs):
        """ Validates if the order_proof is correct or not.
              -If the slot is not present in the predecessor replica's slot
               then returns false.
              -If the order is not present in the predecessor's order.
               then returns false.
              -If the sign verification of the order_proof with predecessor
               replica's verify key fails, then return false.
               -If the order proof size is zero then return false.
              -otherwise TRUE. """

        if len(order_proofs) < 1:
            logging.error("MISBEHAVIOUR: Empty Order Proof ",
                          extra=logger.NODE_INFO)
            return False
        slot = order_proofs[0][0]
        order = order_proofs[0][1]
        if slot in cache:
            logging.error("MISBEHAVIOUR: Conflicting slot. Slot already " +
                          "present in cache. {SlotNo: %s}", slot,
                          extra=logger.NODE_INFO)
            return False
        for ind in range(0, replica_no):
            order_proof = order_proofs[ind]
            pred_slot = order_proof[0]
            pred_order = order_proof[1]
            if slot != pred_slot or order != pred_order:
                logging.error("MISBEHAVIOUR: Unknown slot or OrderNo not " +
                              "present in Order_Proof. {SlotNo: %s, OrderNo:" +
                              " %s} {Predecessor Replica Slot No: %s ," +
                              "Predecessor Replica Order No: %s}", slot, order,
                              pred_slot, pred_order, extra=logger.NODE_INFO)
                return False
            for sec in range(0, ind + 1):
                verify_key = replica_verify_keys[sec]
                try:
                    verify_key.verify(order_proof[3][sec])
                except nacl.exceptions.BadSignatureError:
                    logging.error("MISBEHAVIOUR: Bad signature error in " +
                                  "Order Proof", extra=logger.NODE_INFO)

                    return False
        return True

    def get_slot_order(order_proof):
        """ Fetches the slot from the first verified order_proof. """
        first_order_st = order_proof[0]
        return first_order_st[0], first_order_st[1]

    # Retransmission ack from head to replica
    def receive(msg=('retransmission_ack', order_id), from_=replicas[0]):
        """ Receives the retransmission acknowledgement from the HEAD to cancel
            the timeout of itself. """

        if prev != None:
            print("Received ack from head for retransmission, ",
                  "Cancelling timeout")
            logging.info("Received ack from head for retransmission, " +
                         "cancelling timeout", extra=logger.NODE_INFO)

    # Eventually head will deal with re-transmission from replicas
    def receive(msg=('retransmission_to_head', client, client_no, replica,
                order_id, order,)):
        """ Receives the retransmission message from the CLIENT. If the result
            is not present in the cache then it will forward the request to the
            HEAD to handle it. It also starts a time waiting for HEAD's ACK. If
            the acknowledgement is not received then then trigger
            reconfiguration to olympus. """

        if state == "IMMUTABLE":
            return

        if self.prev == None:

            client_last_op[client_no] = order

            if client_no not in client_fwd_rqst_counter:
                client_fwd_rqst_counter[client_no] = 0
            client_fwd_rqst_counter[client_no] += 1
            print('Retransmission request forwarded from replica ......')
            logging.info("Retransmission request forwarded from replica" +
                         "......", extra=logger.NODE_INFO)

            if order_id in cache and len(cache[order_id]) == 2:
                send(('retransmission_result', cache[order_id], replica_no, order_id,),
                     to=client)

                logging.info("Sending retransmission_ack ACK: {orderId: %s}",
                             str(order_id), extra=logger.NODE_INFO)

                send(('retransmission_ack', order_id), to=replica)

            elif order_id in cache and len(cache[order_id]) == 1:
                if await(len(cache[order_id]) == 2):
                    send(('retransmission_result', cache[order_id],
                         replica_no, order_id,), to=client)
                    send(('retransmission_ack', order_id), to=replica)

                elif timeout(int(time_out) / 1000):
                    handle_client_req_at_head(client, client_no, order_id,
                                              order)
                    if await(len(cache[order_id]) == 2):
                        send(('retransmission_result', cache[order_id],
                              replica_no, order_id,), to=client)
                        send(('retransmission_ack', order_id), to=replica)

                    elif timeout(int(time_out) / 1000):
                        print("Request of reconfiguration from head")
                        logging.info("Request of reconfiguration from head",
                                     extra=logger.NODE_INFO)
            else:
                handle_client_req_at_head(client, client_no, order_id, order)
                if await(len(cache[order_id]) == 2):
                    send(('retransmission_result', cache[order_id], \
                            replica_no, order_id,), to=client)
                    send(('retransmission_ack', order_id), to=replica)

                elif timeout(int(time_out) / 1000):
                    print("Request of reconfiguration from head")
                    logging.info("Request of reconfiguration from head", \
                                                        extra=logger.NODE_INFO)

        else:
            print("Only head has to eventually deal with re transmission" +
                  "request")

    def handle_client_req_at_head(client, client_no, unique_order_ide,
                                  order_req):
        """ Handles the client order request. It assigns a slot to order and
            then create the order_proof and result_proof which is forwarded
            along the chain. """

        print("Received order request at head : ", order_req)

        current_slot += 1
        # No need to verify order proof at head
        order_proofs = []

        # Order proof is a list of tuples (slot, order, replica, [digtal signs
        # of preceding])
        order_proofs.append(create_order_proof(current_slot, order_req))
        result = command_executor.get_result(order_req, running_state)
        injected_result = get_injected_result(client_no, client_shuttle_counter[client_no])
        if injected_result != None:
            result = injected_result
        if result != None:
            cache[unique_order_ide] = [result]
            result_proof = []
            result_proof.append(create_result_proof(result, order_req))

            if get_injected_drop_stmt(client_no,
                                      client_shuttle_counter[client_no]):
                result_proof = []

            logging.info("HEAD sending FORWARD_SHUTTLE to next replica in " +
                         "chain. { OrderNo: %s, OrderRequest: %s, " +
                         "NextReplicaName: %s ClientNo: %s, RESULT: %s }",
                         unique_order_ide, str(order_req),
                         replicas_name[int(replica_no)+1], str(client_no),
                         result, extra=logger.NODE_INFO)
            history.append(order_proofs)
            send(('forward_shuttle', client, client_no, unique_order_ide,
                  order_proofs, result_proof,), to=next_r)

    def set_global_operation(order):
        global_operation = order

    def get_injected_drop_stmt(client_no, msg_count):
        key = str(client_no)
        if key in injected_drop_result.keys():
            val = injected_drop_result[key]
            if int(val) + 1 == int(msg_count):
                return True
        return False

    def get_injected_result(client_no, msg_count):
        key = str(client_no)
        if key in injected_change_result.keys():
            val = injected_change_result[key]
            if int(val) + 1 == int(msg_count):
                return "OK"
        return None

    def get_injected_operation(client_no, msg_count):
        key = str(client_no)
        if key in injected_get_operation.keys():
            val = injected_get_operation[key]
            if int(val) + 1 == int(msg_count):
                return "get('x')"
        return global_operation

    def set_trigger_for_change_operation(client_no, msg_num):
        key = str(client_no)
        injected_get_operation[key] = msg_num

    def set_trigger_for_change_result(client_no, msg_num):
        key = str(client_no)
        injected_change_result[key] = msg_num

    def set_trigger_for_drop_result_stmt(client_no, msg_num):
        key = str(client_no)
        injected_drop_result[key] = msg_num

    def trigger_failure_injection_for_shuttle(client_no, msg_count_by_client):
        key = str(client_no) + "_" + str(msg_count_by_client)
        if str(key) in client_shuttle_trigger:
            val = client_shuttle_trigger[key]
            if val == "change_operation":
                set_trigger_for_change_operation(client_no, msg_count_by_client)
            elif val == "change_result":
                set_trigger_for_change_result(client_no, msg_count_by_client)
            elif val == "drop_result_stmt":
                set_trigger_for_drop_result_stmt(client_no,
                                                 msg_count_by_client)

    def extract_slot_order_map_from_history(rep_history):
        slot_order_map = {}
        for list_order_proofs in rep_history:
            for order_proofs in list_order_proofs:
                slot_order_map[order_proofs[0]] = order_proofs[1]
        return slot_order_map


    def start_check_pointing():
        if self.prev == None:
            chk_point_proof = {}

            '''msg = 16 * str.encode(str(replica_no))
            digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
            signed = sign_key.sign(digest)'''
            chk_point_proof[replica_no] = extract_slot_order_map_from_history(history)
            print("checkpointing started *********************** ", len(chk_point_proof))
            send(('chk_point_frwd', chk_point_proof, checkpoint_ind + 1,), to=next_r)


    def get_slot_order_intersection(slot_order_map_1, slot_order_map_2):
        result = {}
        for key in slot_order_map_1.keys():
            if key in slot_order_map_2:
                val_1 = slot_order_map_1[key]
                val_2 = slot_order_map_2[key]
                if val_1 == val_2:
                    result[key] = val_1
                else:
                    return None
        return result

    def get_Min_Check_Pt_Map(chk_point_proof):
        if chk_point_proof == None:
            return None
        if len(chk_point_proof) < 2:
            return chk_point_proof

        result = {}

        result = chk_point_proof[0]
        for ind in range(1, len(replicas)):
            result = get_slot_order_intersection(result, chk_point_proof[ind])
        return result

    def get_result_history(rslt_chk_pt, history):
        result = []
        for his in history:
            temp = []
            for order_proofs in his:
                slot_no = order_proofs[0]
                order = order_proofs[1] ## No need to verify again
                if slot_no not in rslt_chk_pt.keys():
                    temp.append(order_proofs)
            if len(temp) != 0:
                result.append(temp)
        return result


    def is_valid_chk_pt_proof(chk_point_proof, replica_no):
        if len(chk_point_proof) < 2:
            return True
        result_slot_order_map = chk_point_proof[0]
        for ind in range(1, replica_no):
            verify_key = replica_verify_keys[ind]
            curr_order_ = chk_point_proof[ind]

            curr_slot_order_map = extract_slot_order_map_from_history(history)
            result_slot_order_map = get_slot_order_intersection(result_slot_order_map, curr_slot_order_map)
            if result_slot_order_map == None:
                return False
            '''try:
                print("roku2")
                verify_key.verify(chk_point_proof[ind][1])
                print("roku3")
            except nacl.exceptions.BadSignatureError:
                print("roku4")
                return False
            except IndexError:
                print("roku5")
                return False'''
        return True

    def receive(msg=('chk_point_rslt', chk_point_proof, chk_point_index,), from_=self.next_r):
        rslt_chk_pt = get_Min_Check_Pt_Map(chk_point_proof)
        rslt_history = get_result_history(rslt_chk_pt, history)

        ## update values
        checkpoint_ind = chk_point_index
        checkpoint.update(rslt_chk_pt)
        history = rslt_history

        print("checkpont Completed ***********************")
        print(checkpoint_ind, " - ", client_last_op)
        print(checkpoint)
        print("History : ")
        for his in history:
            for order_proofs in his:
                print("slot - ", order_proofs[0], " order - ", order_proofs[1], \
                    " replica - ", order_proofs[2], "  sign - ", len(order_proofs[3]))
        print("checkpont return Success ***********************")

        if self.prev != None:
            send(('chk_point_rslt', chk_point_proof, chk_point_index,), to=prev)


    def receive(msg=('chk_point_frwd', chk_point_proof, chk_point_index,), from_=self.prev):
        if checkpoint_ind + 1 == chk_point_index:
            if is_valid_chk_pt_proof(chk_point_proof, replica_no):

                '''msg = 16 * str.encode(str(replica_no))
                digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
                signed = sign_key.sign(digest)'''
                chk_point_proof[replica_no] = extract_slot_order_map_from_history(history)
                print("valid checkpointing received ******************** ", len(chk_point_proof))
                if next_r != None:
                    send(('chk_point_frwd', chk_point_proof, chk_point_index,), to=next_r)
                else:
                    rslt_chk_pt = get_Min_Check_Pt_Map(chk_point_proof)
                    rslt_history = get_result_history(rslt_chk_pt, history)

                    ## update values
                    checkpoint_ind = chk_point_index
                    checkpoint.update(rslt_chk_pt)
                    history = rslt_history

                    '''print("checkpont return Completed ***********************")
                    print(checkpoint)
                    print(history)
                    print("checkpont return Success ***********************")'''
                    send(('chk_point_rslt', chk_point_proof, chk_point_index,), to=prev)
            else:
                print("checkpointing failed verification, invoke reconfiguration")


    def receive(msg=('new_configuration', config_ind, chk_pt_ind, chk_pt,), from_=olympus):
        print("Received new configuration ======, ", chk_pt)
        self.config = config_ind
        self.history = []
        self.opr_count_chk_pt = 0
        self.checkpoint_ind = chk_pt_ind
        self.checkpoint = chk_pt
        self.client_last_op = {}
        self.current_slot = 0
        self.running_state = {}
        self.cache = {}

        for slot in sorted(checkpoint.keys()):
            result = command_executor.get_result(checkpoint[slot], running_state)
            ## TODO: update cache
            current_slot = slot

        self.state = "ACTIVE"

    def build_slot_order_map(history):
        slot_order_map = {}
        for order_proofs in history:
            slot_no = order_proofs[0][0]
            operation = order_proofs[0][1]
            slot_order_map[slot_no]= operation
        return slot_order_map

    def catch_longest_hist(slot_order_map, long_hist):
        for key in long_hist.keys():
            if key not in slot_order_map:
                slot_order_map[key] = long_hist[key]
        return slot_order_map

    def receive(msg=('catch_up', long_hist), from_=olympus):
        print("sending caught up to olympus")
        slot_order_map = build_slot_order_map(history)
        catched_history = catch_longest_hist(slot_order_map, long_hist)
        catched_hist_str = json.dumps(catched_history)
        print("catched_hist_str ********* ", catched_hist_str)
        msg = 16 * str.encode(catched_hist_str)
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        send(('caught_up', replica_no, digest), to=olympus)


    def receive(msg=('wedge',), from_=olympus):
        print("wedge statement received from olympus")
        self.state = "IMMUTABLE"
        send(('wedge_resp', replica_no, checkpoint_ind, \
            checkpoint, history, client_last_op), to=olympus)


    # Only head is supposed to handle order request from client
    def receive(msg=('request_order', client, client_no, unique_order_ide,
                     order_req,)):
        if self.prev == None:
            #send(('req_reconfiguration', replica_no), to=olympus)

            ## If state is not ACTIVE return
            if state == "IMMUTABLE":
                return

            client_last_op[client_no] = order_req

            logging.info("HEAD received ORDER_REQUEST from client. { OrderNo" +
                         ": %s, OrderRequest: %s, ClientNo: %s }",
                         unique_order_ide, str(order_req), str(client_no),
                         extra=logger.NODE_INFO)

            self.opr_count_chk_pt = self.opr_count_chk_pt + 1
            if self.opr_count_chk_pt % 3 == 0:
                print("checkpointing counter - ", opr_count_chk_pt)
                start_check_pointing()
                if checkpoint_ind == 2:
                    send(('req_reconfiguration', replica_no), to=olympus)

            if client_no not in client_shuttle_counter:
                client_shuttle_counter[client_no] = 0
            client_shuttle_counter[client_no] += 1
            # Injected code ---- Start
            set_global_operation(order_req)
            trigger_failure_injection_for_shuttle(client_no,
                                                  client_shuttle_counter
                                                  [client_no])
            order = get_injected_operation(client_no,
                                           client_shuttle_counter[client_no])
            # Injected code -----End
            handle_client_req_at_head(client, client_no, unique_order_ide,
                                      order)
        else:

            logging.info("Only HEAD must take order request from client",
                         extra=logger.NODE_INFO)
        return

    # Forward Shuttle to next
    def receive(msg=('forward_shuttle', client, client_no, unique_order_ide,
                     order_proofs, result_proofs, ), from_=self.prev):

        logging.info("Received FORWARD_SHUTTLE from previous replica in " +
                     "chain. { OrderNo: %s, OrderRequest: %s ClientNo: %s " +
                     " PreviousReplicaName: %s", unique_order_ide,
                     order_proofs[0][1], str(client_no),
                     replicas_name[int(replica_no)-1], extra=logger.NODE_INFO)

        if self.next_r != None:

            print("Received forward shuttle - ", unique_order_ide)

            if state == "IMMUTABLE":
                return

            if client_no not in client_shuttle_counter:
                client_shuttle_counter[client_no] = 0
            client_shuttle_counter[client_no] += 1
            if is_valid_order_proofs(order_proofs):
                current_slot, order_req = get_slot_order(order_proofs)

                client_last_op[client_no] = order_req

                # Injected code ----- Start
                set_global_operation(order_req)
                trigger_failure_injection_for_shuttle(client_no,
                                                      client_shuttle_counter
                                                      [client_no])

                order_req = get_injected_operation(client_no,
                                                   client_shuttle_counter
                                                   [client_no])
                # Injected code ----- End

                predecessor_order_proof = order_proofs[replica_no - 1][3]
                order_proofs.append(combine_order_proof(current_slot,
                                    order_req, predecessor_order_proof))
                result = command_executor.get_result(order_req, running_state)

                # Injected code ----- Start
                injected_result = get_injected_result(client_no,
                                                      client_shuttle_counter
                                                      [client_no])
                if injected_result != None:
                    result = injected_result
                # Injected code ----- End

                history.append(order_proofs)
                cache[unique_order_ide] = [result]
                predecessor_results = result_proofs[replica_no - 1][3]
                result_proofs.append(combine_result_proof(result, order_req,
                                     predecessor_results))

                # Injected code ----- Start
                if get_injected_drop_stmt(client_no,
                                          client_shuttle_counter[client_no]):
                    result_proofs = result_proofs[1:]
                # Injected code ----- End

                logging.info("Sending FORWARD_SHUTTLE to next replica in " +
                             "chain. {OrderNo: %s, OrderRequest: %s ClientNo" +
                             ":%s NextReplicaName: %s }", unique_order_ide,
                             order_proofs[0][1], str(client_no),
                             replicas_name[int(replica_no)+1],
                             extra=logger.NODE_INFO)
                print ("Forwarding shuttle - ", unique_order_ide)
                send(('forward_shuttle', client, client_no, unique_order_ide,
                     order_proofs, result_proofs,), to=self.next_r)
            # else make reconfiguration call to olympus
        else:

            if client_no not in client_shuttle_counter:
                client_shuttle_counter[client_no] = 0
            client_shuttle_counter[client_no] += 1
            print("Received forward shuttle - ", unique_order_ide)

            if is_valid_order_proofs(order_proofs):
                current_slot, order_req = get_slot_order(order_proofs)

                client_last_op[client_no] = order_req

                # Injected code ------ Start
                set_global_operation(order_req)
                trigger_failure_injection_for_shuttle(client_no,
                                                      client_shuttle_counter
                                                      [client_no])

                order_req = get_injected_operation(client_no,
                                                   client_shuttle_counter
                                                   [client_no])

                result = command_executor.get_result(order_req, running_state)
                injected_result = get_injected_result(client_no,
                                                      client_shuttle_counter
                                                      [client_no])
                if injected_result != None:
                    result = injected_result
                # Injected code ------ End
                predecessor_results = result_proofs[replica_no - 1][3]
                result_proofs.append(combine_result_proof(result, order_req,
                                     predecessor_results))
                cache[unique_order_ide] = [result, result_proofs]
                # Injection code ----- Start
                if get_injected_drop_stmt(client_no,
                                          client_shuttle_counter
                                          [client_no]):
                    result_proofs = result_proofs[1:]
                    # Injected code ------ End

                logging.info("Sending RESULT_PROOF to Client. { OrderNo:" +
                             " %s, OrderRequest: %s Result: %s ClientNo:" +
                             " %s }", unique_order_ide, order_proofs[0][1],
                             result, str(client_no),
                             extra=logger.NODE_INFO)

                print ("sending result proof to client - ", unique_order_ide)
                send(('result_proof', result_proofs,
                        self.replica_no, unique_order_ide), to=client)
                predecessor_order_proof = order_proofs[replica_no - 1][3]
                order_proofs.append(combine_order_proof(current_slot,
                                    order_req, predecessor_order_proof))
                history.append(order_proofs)

                logging.info("Sending REVERSE_SHUTTLE to previous " +
                             "replica in chain. { OrderNo: %s, " +
                             "OrderRequest: %s Result: %s ClientNo: " +
                             "%s PreviousReplicaName: %s }",
                             unique_order_ide, order_proofs[0][1], result,
                             str(client_no),
                                replicas_name[int(replica_no)-1],
                             extra=logger.NODE_INFO)
                print ("sending back result proof - ", unique_order_ide)
                print("checkpont Completed ***********************")
                print(checkpoint_ind, " -  ", client_last_op)
                print(checkpoint)
                print("History : ")
                for his in history:
                    for order_proofs in his:
                        print("slot - ", order_proofs[0], " order - ", order_proofs[1], \
                            " replica - ", order_proofs[2], "  sign - ", len(order_proofs[3]))
                print("checkpont return Success ***********************")

                send(('result_shuttle', unique_order_ide, client_no,
                      result_proofs,), to=self.prev)
            else:
                print ("order proof verification failed  - ", unique_order_ide)
            return
                #else:  No verification for result proof at tail
                #    print("Result proof error so raise reconfiguration")

    def trigger_failure_injection_for_result_shuttle( \
            client_no, msg_count_by_client):
        key = str(client_no) + "_" + str(msg_count_by_client)
        if str(key) in client_result_shuttle_trigger:
            val = client_result_shuttle_trigger[key]
            if val == "change_operation":

                logging.info("Injected change_operation",
                             extra=logger.NODE_INFO)
                set_trigger_for_change_operation(client_no,
                                                 msg_count_by_client)
            elif val == "change_result":

                set_trigger_for_change_result(client_no, msg_count_by_client)
                logging.info("Injected change_result", extra=logger.NODE_INFO)

            elif val == "drop_result_stmt":

                logging.info("Injected drop_result_statement",
                             extra=logger.NODE_INFO)
                set_trigger_for_drop_result_stmt(client_no,
                                                 msg_count_by_client)

    # Return Shuttle from next
    def receive(msg=('result_shuttle', unique_order_ide, client_no,
                     result_proof_pair,), from_=self.next_r):

        if self.state == "IMMUTABLE":
            return

        if self.next_r != None:
            logging.info("Received REVERSE_SHUTTLE from next replica in " +
                         "chain. { OrderNo: %s, ClientNo: %s Result: %s}",
                         str(unique_order_ide), str(client_no),
                         result_proof_pair[0][0], extra=logger.NODE_INFO)

        if client_no not in client_result_shuttle_counter:
            client_result_shuttle_counter[client_no] = 0
        client_result_shuttle_counter[client_no] += 1
        # Injected code ---- Start
        trigger_failure_injection_for_shuttle(client_no,
                                              client_result_shuttle_counter
                                              [client_no])
        # Injected code -----End
        print("Received result shuttle from next for - ", unique_order_ide)
        try:
            result_with_proof = cache[unique_order_ide]
            result_with_proof.append(result_proof_pair)
            cache[unique_order_ide] = result_with_proof
            # Injected code ----------- Start
            injected_result = get_injected_result(client_no,
                                              client_result_shuttle_counter
                                              [client_no])
            if injected_result != None:
                result_proofs = result_proof_pair[1]
                result_proof_pair = ("OK", result_proofs)
            if get_injected_drop_stmt(client_no,
                                  client_result_shuttle_counter[client_no]):
                result_proofs = result_proof_pair[1][1:]
                result_proof_pair = (result_proof_pair[0], result_proofs)
            # Injected code ------ End
            if self.prev != None:
                logging.info("Sending REVERSE_SHUTTLE to previous replica in " +
                             "chain. { OrderNo: %s, ClientNo: %s Result: %s }",
                             str(unique_order_ide), str(client_no),
                             result_proof_pair[0][0], extra=logger.NODE_INFO)
                if is_valid_result_proof(result_proof_pair, result_with_proof[0]):
                    send(('result_shuttle', unique_order_ide, client_no,
                          result_proof_pair,), to=self.prev)
                else:
                    print("Raise reconfiguration as result proof has exception")
            print("checkpont Completed ***********************")
            print(checkpoint_ind, " - ", client_last_op)
            print(checkpoint)
            print("History : ")
            for his in history:
                for order_proofs in his:
                    print("slot - ", order_proofs[0], " order - ", order_proofs[1],\
                         " replica - ", order_proofs[2], "  sign - ", len(order_proofs[3]))
            print("checkpont return Success ***********************")
        except KeyError:
            print("Due to new configuration, client is required to resend this order")
        return

    def trigger_failure_injection_for_cl_dr_msg(client_no,
                                                msg_count_by_client):
        key = str(client_no) + "_" + str(msg_count_by_client)
        if str(key) in client_direct_msg_trigger:
            val = client_direct_msg_trigger[key]
            if val == "change_operation":
                set_trigger_for_change_operation(client_no,
                                                 msg_count_by_client)
            elif val == "change_result":
                set_trigger_for_change_result(client_no, msg_count_by_client)
            elif val == "drop_result_stmt":
                set_trigger_for_drop_result_stmt(client_no,
                                                 msg_count_by_client)

    # Re-transmission from client
    def receive(msg=('retransmission', client, client_no, order_id, order,)):

        logging.info("Received retransmission request from Client. {OrderNo:" +
                     "%s, Order: %s, ClientNo: %s, ClientId: %s}",
                     str(order_id), str(order), str(client_no), str(client),
                     extra=logger.NODE_INFO)

        if state == 'IMMUTABLE':
            return

        client_last_op[client_no] = order

        if client_no not in client_direct_msg_counter:
            client_direct_msg_counter[client_no] = 0
        client_direct_msg_counter[client_no] += 1
        print("Retrnsmission request received - ", order_id)
        set_global_operation(order)
        trigger_failure_injection_for_shuttle(client_no,
                                              client_direct_msg_counter
                                              [client_no])
        order_req = get_injected_operation(client_no,
                                           client_direct_msg_counter
                                           [client_no])
        if order_id in cache and len(cache[order_id]) == 2:
            logging.info("Found result in cache. { OrderNo: %s}", order_id,
                         extra=logger.NODE_INFO)

            result = cache[order_id][0]
            result_proofs = cache[order_id][1]
            injected_result = get_injected_result(client_no,
                                                  client_direct_msg_counter
                                                  [client_no])
            if injected_result != None:
                result = "OK"
            if get_injected_drop_stmt(client_no,
                                      client_direct_msg_counter[client_no]):
                result_proofs = result_proofs[1][1:]
            result_proof_pair = (result, result_proofs)

            logging.info("Retransmission result send to client from cached" +
                         "result. {RESULT: %s , FromReplica: %s ToClient: %s}",
                         result_proof_pair[0], str(replica_no), str(client_no),
                         extra=logger.NODE_INFO)

            print("sending retransmission respose from cache for - ", order_id)
            send(('retransmission_result', result_proof_pair, replica_no, order_id,),
                 to=client)
        else:
            logging.info("Retransmission request send to HEAD. {OrderNo: %s" +
                         "OrderRequest: %s ClientNo: %s ClientId: %s}",
                         str(order_id), str(order_req), str(client_no),
                         str(client), extra=logger.NODE_INFO)

            print("since trans rqst not in cache, forwarding to head")
            send(('retransmission_to_head', client, client_no,  self,
                 order_id, order_req,), to=replicas[0])
            if await(received(('retransmission_ack', order_id))):
                print("Ack from head received, do nothing")
                logging.info("Retransmission ACK received from HEAD for " +
                             "OrderNo {%s}. Do nothing !!!", order_id,
                             extra=logger.NODE_INFO)

            elif timeout(int(time_out) / 1000):
                print("Reconfiguration request raised by ", self)
                logging.info("Reconfiguration request raised by self",
                             extra=logger.NODE_INFO)

    def run():
        print("Replica : ", str(self.me))
        logging.info("Running Replica...", extra=logger.NODE_INFO)
        set_failure_triggers()
        while True:
            await(received(('',)))
