#!/usr/bin/python3
# -*- coding: utf-8 -*-

import sys
import os
import logging
import json
from src.utils import logger
import nacl.encoding
import nacl.signing
import time


# Configuration Params to be read from config file

HOST = 'olympus_host'
HASHER = nacl.hash.sha256
current_milli_time = lambda: int(round(time.time() * 1000))

class olympus(process):
    """ An implementation to handle the singleton Olympus. """

    def setup(config_file, replica_list, replica_name, name, nodeId,
              signing_key, replica_verify_keys):
        """ Setting up the Olympus based on configuration."""

        # Setting the logging format for the CONFIG_NODE
        # Default logging is INFO for CONFIG_NODE.
        # Other applicable values - logging.WARN, logging.CRITICAL,
        # logging.ERROR, logging.DEBUG
        # Use respective logging.warn, logging.critical, logging.error,
        # logging.debug

        logger.setLogFormatting(self.name + '.log', logger.getLogDir(),
                                logging.INFO)
        logger.setLogNodeInfo(self.nodeId, self.name)

        # Log the received values

        logging.info("Received setup - config_file: %s " +
                     "replica_list: %s replica_name: %s", config_file,
                     replica_list, replica_name, extra=logger.NODE_INFO)

        self.quorum_size = ((len(replica_list) - 1) / 2) + 1

        self.is_reconfig_in_progress = False
        self.replica_info = {}
        self.config = 0
        self.consistent_caught_up = {}
        self.reconfig_running_state = None
        self.reconfig_hash_value = None
        return

    def is_checkpoint_consistent(replica_info):
        if len(replica_info) < 2:
            return False
        chk_pt_ind = -1
        chk_pt = ""
        for key in replica_info.keys():
            value = replica_info[key]
            if chk_pt_ind == -1 and len(chk_pt) == 0:
                chk_pt_ind = value[0]
                chk_pt = value[1]
                continue
            if chk_pt_ind != value[0]:
                return False
            else:
                if len(chk_pt) != len(value[1]):
                    return False
                for sec in chk_pt.keys():
                    val1 = chk_pt[sec]
                    if sec not in value[1].keys():
                        return False
                    val2 = value[1][sec]
                    if val1 != val2:
                        return False
        return True

    def build_longest_history(replica_info):
        if len(replica_info) < 2:
            return None
        longest_hist = {}
        for key in replica_info.keys():
            hist = replica_info[key][2]
            for order_proofs in hist:
                slot_no = order_proofs[0][0]
                operation = order_proofs[0][1]
                if slot_no in longest_hist.keys():
                    prev_oper = longest_hist[slot_no]
                    if prev_oper != operation:
                        return None
                else:
                    longest_hist[slot_no] = operation

        return longest_hist


    def is_history_consistent(replica_info):
        long_hist = build_longest_history(replica_info)
        if long_hist == None:
            return False
        return True


    def has_consistent_history_chk_pt(replica_info):
        if not is_checkpoint_consistent(replica_info):
            return False
        if not is_history_consistent(replica_info):
            return False
        return True

    def receive(msg=('wedge_resp', replica_no, chk_pt_ind, chk_pt, hist, client_ord)):
        print("Reconfiguration  response received from ", replica_no)
        if len(replica_info) == 0:
            config += 1

        replica_info[replica_no] = (chk_pt_ind, chk_pt, hist, client_ord)

        if len(replica_info) == quorum_size:
            print("quorum replica - ", replica_info.keys())
            if has_consistent_history_chk_pt(replica_info) == False:
                is_reconfig_in_progress = False
                for replica in replica_list:
                    send(('wedge',), to=replica)
                await(len(setof(a, received(('wedge_resp', _, _,_,_,_), from_=a))) == quorum_size)
            else:
                long_hist = build_longest_history(replica_info)
                if is_caught_up_consistent(replica_info, long_hist) and get_running_state() != None:
                    new_chk_point = chk_pt
                    new_chk_point.update(long_hist)
                    running_state = get_running_state()
                    config += 1
                    for replica in replica_list:
                        send(('new_configuration', config, chk_pt_ind + 1, \
                                new_chk_point, running_state,), to=replica)
                    print("Awaiting new configuration accepted")    
                    length = ( 2 * quorum_size ) + 1
                    replica_info = {}
                    await(len(setof(a, received(('new_config_done',_,), from_=a))) == length)
                    replica_info = {}
                    is_reconfig_in_progress = False
                else:
                    is_reconfig_in_progress = False
                    for replica in replica_list:
                        send(('wedge',), to=replica)
                    await(len(setof(a, received(('wedge_resp', _, _,_,_,_), from_=a))) == quorum_size)

        is_reconfig_in_progress = False
        return

    def verify_running_state(running_state):
        msg = 16 * str.encode(json.dumps(running_state))
        digest = HASHER(msg, encoder=nacl.encoding.HexEncoder)
        if digest == reconfig_hash_value:
            reconfig_running_state = running_state
            return True
        else:
            return False

    def receive(msg=('rcv_running_state', replica_no, running_state)):
        if verify_running_state(running_state):
            print("Valid running state for ", replica_no)
        else:
            print("Invalid running state for ", replica_no)

    def get_running_state():
        for key in consistent_caught_up.keys():
            send(('get_running_state',), to=replica_list[key])
        await(len(setof(a, received(('rcv_running_state',_,_,), from_=a))) == quorum_size)
        return reconfig_running_state

    def is_caught_up_consistent(replica_info, long_hist):
        consistent_caught_up = {}
        reconfig_running_state = None
        reconfig_hash_value = None
        for ind in replica_info.keys():
            replica = replica_list[ind]
            send(('catch_up', long_hist), to=replica)
        print("Awaitaing for caught up response from ", replica_info.keys())
        await(len(setof(a, received(('caught_up', _, _), from_=a))) == quorum_size)
        print("Await ended")
        hash_value = ""
        for key in consistent_caught_up.keys():
            if len(hash_value) == 0:
                hash_value = consistent_caught_up[key]
            elif hash_value != consistent_caught_up[key]:
                return False
        reconfig_hash_value = hash_value    
        return True


    def receive(msg=('new_config_done', client_no)):
        print("New config done for ", client_no)

    def receive(msg=('caught_up', client_no, hash_value)):
        consistent_caught_up[client_no] = hash_value
        print("Received caught up from ", client_no, " is - ", hash_value)

    def receive(msg=('req_reconfiguration', replica_no)):
        if is_reconfig_in_progress == True:
            return
        is_reconfig_in_progress = True
        print("Reconfiguration  request received from ", replica_no)
        for replica in replica_list:
            send(('wedge',), to=replica)
        await(len(setof(a, received(('wedge_resp', _, _,_,_,_), from_=a))) >= quorum_size)
        for replica in replica_list:
            send(('activate',), to=replica)
        print("Awaiting activation ack")
        await(len(setof(a, received(('ack_activate', _), from_=a))) == len(replica_list))
        return

    def receive(msg=('ack_activate', replica_no)):
        print("Rcv activate acknowledgement from client - ", replica_no)

    def receive(msg=('req_curr_config', client)):
        """ Receives the CURRENT_CONFIG request from client. """

        logging.info("Received request CURRENT_CONFIG from %s",
                     str(client), extra=logger.NODE_INFO)
        if client is not None:
            logging.info("Sending CURRENT_CONFIG to : %s", str(client),
                         extra=logger.NODE_INFO)
            if is_reconfig_in_progress == False:
                send(('rcv_curr_config', replica_list, replica_name,
                    replica_verify_keys), to=client)
            else:
                send(('rcv_curr_config', [], [], []), to=client)
        else:
            logger.setLogFormatting(self.name + '.log',
                                    logger.getLogDir(), logging.ERROR)
            logging.error('Request from illegal client',
                          extra=logger.INFO)

    def run():
        """ Waits infinitely for serving any request.  """

        logging.info("Running Olympus- {Name: %s, Id: %s}", self.name, nodeId,
                     extra=logger.NODE_INFO)
        print("Olympus running waiting to serve request !!! ")

        while True:
            await(received(('', )))
